using System;
using System.Linq;
using cAlgo.API;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;
using System.Collections.Generic;
using System.Text;
using System.Globalization;
using System.Security.Cryptography;
using System.Reflection;

namespace cAlgo
{
    [Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.FullAccess)]
    public class TEMA_Scalper_Levels_MomentumSnap : Robot
    {
        // =========================
        //   A) FUNDACIONES
        // =========================
        [Parameter("Use Fixed Lots", Group = "A) Fundaciones", DefaultValue = false)]
        public bool UseFixedLots { get; set; }
        [Parameter("Fixed Lots", Group = "A) Fundaciones", DefaultValue = 0.01, MinValue = 0.01, MaxValue = 10.0, Step = 0.01)]
        public double FixedLots { get; set; }
        [Parameter("Profile", Group = "A) Fundaciones", DefaultValue = "Balanced")]
        public string Profile { get; set; } // Conservative | Balanced | Aggressive
        [Parameter("Trigger Aggressiveness (0-2)", Group = "A) Fundaciones", DefaultValue = 1, MinValue = 0, MaxValue = 2)]
        public int TriggerAgg { get; set; }
        [Parameter("Structure Strictness (0-2)", Group = "A) Fundaciones", DefaultValue = 1, MinValue = 0, MaxValue = 2)]
        public int StructureStrict { get; set; }
        [Parameter("Execution Strictness (0-2)", Group = "A) Fundaciones", DefaultValue = 1, MinValue = 0, MaxValue = 2)]
        public int ExecStrict { get; set; }
        [Parameter("Risk Profile (0-2)", Group = "A) Fundaciones", DefaultValue = 1, MinValue = 0, MaxValue = 2)]
        public int RiskProfile { get; set; }
        // =========================
        //   B) ENTRADAS & FILTROS
        // =========================
        [Parameter("ZonePolicy_BOS", Group = "B) Entradas & Filtros – Zona", DefaultValue = "Either")]
        public string ZonePolicy_BOS { get; set; }
        [Parameter("ZonePolicy_FBK", Group = "B) Entradas & Filtros – Zona", DefaultValue = "Either")]
        public string ZonePolicy_FBK { get; set; }
        [Parameter("ZonePolicy_ENG", Group = "B) Entradas & Filtros – Zona", DefaultValue = "EMA")]
        public string ZonePolicy_ENG { get; set; }
        [Parameter("ZonePolicy_PIN", Group = "B) Entradas & Filtros – Zona", DefaultValue = "EMA")]
        public string ZonePolicy_PIN { get; set; }
        [Parameter("ZonePolicy_MOM", Group = "B) Entradas & Filtros – Zona", DefaultValue = "EMA")]
        public string ZonePolicy_MOM { get; set; }
        [Parameter("MicroBox LB (bars)", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 5, MinValue = 3, MaxValue = 20)]
        public int MicroBoxLB { get; set; }
        [Parameter("Invalidate on 2 Opp Closes", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = true)]
        public bool InvalidateOnTwoOppCloses { get; set; }
        [Parameter("MicroBox Max Range (×ATR)", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 0.9, MinValue = 0.4, MaxValue = 2.0)]
        public double MicroBoxMaxRangeAtrMult { get; set; }
        [Parameter("Opp Close Beyond (×ATR)", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 0.20, MinValue = 0.10, MaxValue = 0.50)]
        public double MicroBoxOppBeyondAtrMult { get; set; }
        // --- Sesiones ---
        [Parameter("EnableSessionFilter", Group = "B) Entradas & Filtros – Sesiones", DefaultValue = true)]
        public bool EnableSessionFilter { get; set; }
        [Parameter("Session1Start (HH:mm)", Group = "B) Entradas & Filtros – Sesiones", DefaultValue = "08:05")]
        public string Session1Start { get; set; }
        [Parameter("Session1End (HH:mm)", Group = "B) Entradas & Filtros – Sesiones", DefaultValue = "11:30")]
        public string Session1End { get; set; }
        [Parameter("Session2Start (HH:mm)", Group = "B) Entradas & Filtros – Sesiones", DefaultValue = "14:35")]
        public string Session2Start { get; set; }
        [Parameter("Session2End (HH:mm)", Group = "B) Entradas & Filtros – Sesiones", DefaultValue = "17:30")]
        public string Session2End { get; set; }
        [Parameter("Session Offset Minutes", Group = "B) Entradas & Filtros – Sesiones", DefaultValue = 0, MinValue = -720, MaxValue = 720)]
        public int SessionOffsetMinutes { get; set; }
        // --- Filtros básicos ---
        [Parameter("SpreadMaxPips", Group = "B) Entradas & Filtros – Básicos", DefaultValue = 0.30, MinValue = 0.0)]
        public double SpreadMaxPips { get; set; }
        [Parameter("Confirm Bars", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 2, MinValue = 1, MaxValue = 3)]
        public int ConfirmBars { get; set; }
        [Parameter("ATR_Min (pips)", Group = "B) Entradas & Filtros – Básicos", DefaultValue = 2.5, MinValue = 0.0)]
        public double ATR_Min_Pips { get; set; }
        [Parameter("Reentry Block Bars", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 10, MinValue = 0, MaxValue = 100)]
        public int ReentryBlockBars { get; set; }
        [Parameter("Reentry Box Lookback", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 5, MinValue = 3, MaxValue = 20)]
        public int ReentryBoxLB { get; set; }
        [Parameter("Reentry Box Pad (pips)", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 0.5, MinValue = 0, MaxValue = 5)]
        public double ReentryBoxPadPips { get; set; }
        [Parameter("Unblock On Opp Break", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = true)]
        public bool UnblockOnOppBreak { get; set; }
        // --- Tendencia EMA ---
        [Parameter("Use ATR-Relative EMA Sep", Group = "B) Entradas & Filtros – Tendencia EMA", DefaultValue = false)]
        public bool UseATRRelativeSeparation { get; set; }
        [Parameter("EMA20-EMA50 Sep × ATR", Group = "B) Entradas & Filtros – Tendencia EMA", DefaultValue = 0.60, MinValue = 0.10, MaxValue = 2.00)]
        public double EmaSepAtrMult { get; set; }
        [Parameter("EMAfast", Group = "B) Entradas & Filtros – Tendencia EMA", DefaultValue = 5, MinValue = 3, MaxValue = 20)]
        public int EMAfast { get; set; }
        [Parameter("EMAmed", Group = "B) Entradas & Filtros – Tendencia EMA", DefaultValue = 20, MinValue = 10, MaxValue = 50)]
        public int EMAmed { get; set; }
        [Parameter("EMAslow", Group = "B) Entradas & Filtros – Tendencia EMA", DefaultValue = 50, MinValue = 30, MaxValue = 200)]
        public int EMAslow { get; set; }
        [Parameter("UseTrendFilter", Group = "B) Entradas & Filtros – Tendencia EMA", DefaultValue = true)]
        public bool UseTrendFilter { get; set; }
        [Parameter("MinSep EMA20-EMA50 (pips)", Group = "B) Entradas & Filtros – Tendencia EMA", DefaultValue = 2.0, MinValue = 0.0)]
        public double MinSeparation_EMA20_EMA50_Pips { get; set; }
        // --- Niveles ---
        [Parameter("EnablePrevDayLevels", Group = "B) Entradas & Filtros – Niveles", DefaultValue = true)]
        public bool EnablePrevDayLevels { get; set; }
        [Parameter("EnableAsiaLevels", Group = "B) Entradas & Filtros – Niveles", DefaultValue = true)]
        public bool EnableAsiaLevels { get; set; }
        [Parameter("AsiaStart (HH:mm)", Group = "B) Entradas & Filtros – Niveles", DefaultValue = "00:00")]
        public string AsiaStart { get; set; }
        [Parameter("AsiaEnd (HH:mm)", Group = "B) Entradas & Filtros – Niveles", DefaultValue = "08:00")]
        public string AsiaEnd { get; set; }
        [Parameter("EnableRoundNumbers", Group = "B) Entradas & Filtros – Niveles", DefaultValue = false)]
        public bool EnableRoundNumbers { get; set; }
        [Parameter("RoundStepPips", Group = "B) Entradas & Filtros – Niveles", DefaultValue = 10.0, MinValue = 5.0)]
        public double RoundStepPips { get; set; }
        [Parameter("RequireProximityToLevel", Group = "B) Entradas & Filtros – Niveles", DefaultValue = false)]
        public bool RequireProximityToLevel { get; set; }
        [Parameter("LevelProximityPips", Group = "B) Entradas & Filtros – Niveles", DefaultValue = 5.0, MinValue = 1.0)]
        public double LevelProximityPips { get; set; }
        // --- Gatillos (Triggers) ---
        [Parameter("Reentry Auto Unblock (bars)", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 10, MinValue = 0, MaxValue = 200)]
        public int ReentryAutoUnblockBars { get; set; }
        [Parameter("Reentry Drift Unblock ×ATR", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 1.0, MinValue = 0.2, MaxValue = 3.0)]
        public double ReentryDriftUnblockAtrMult { get; set; }
        [Parameter("BOS Min Body %", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 60, MinValue = 40, MaxValue = 95)]
        public int BosMinBodyPct { get; set; }
        [Parameter("BOS Max Opp Wick ×Body", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 1.2, MinValue = 0.5, MaxValue = 3.0)]
        public double BosMaxOppWickBodyMult { get; set; }
        [Parameter("EntryBuf Extra if Box Wide (pips)", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 0.3, MinValue = 0.0, MaxValue = 2.0)]
        public double EntryBufExtraIfBoxWide { get; set; }
        [Parameter("TriggerCooldownBars", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 3, MinValue = 0, MaxValue = 20)]
        public int TriggerCooldownBars { get; set; }
        [Parameter("EnableTrigger_BOSmicro", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = true)]
        public bool EnableTrigger_BOSmicro { get; set; }
        [Parameter("BOS_MicroBars", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 2, MinValue = 1, MaxValue = 3)]
        public int BOS_MicroBars { get; set; }
        [Parameter("EnableTrigger_Engulfing", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = true)]
        public bool EnableTrigger_Engulfing { get; set; }
        [Parameter("EnableTrigger_PinBar", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = false)]
        public bool EnableTrigger_PinBar { get; set; }
        [Parameter("PinBar Wick %", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 50, MinValue = 30, MaxValue = 90)]
        public int PinBarWickPct { get; set; }
        [Parameter("TriggerTimeoutBars", Group = "B) Entradas & Filtros – Gatillos", DefaultValue = 3, MinValue = 1, MaxValue = 10)]
        public int TriggerTimeoutBars { get; set; }
        // --- MomentumSnap & Pullbacks ---
        [Parameter("Min Candle Range (×ATR)", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = 0.5, MinValue = 0.1, MaxValue = 2.0)]
        public double MinCandleRangeATR { get; set; }
        [Parameter("Max Candle Range (×ATR)", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = 2.0, MinValue = 0.8, MaxValue = 5.0)]
        public double MaxCandleRangeATR { get; set; }
        [Parameter("EnableMomentumSnap", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = true)]
        public bool EnableMomentumSnap { get; set; }
        [Parameter("K_ATR", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = 1.8, MinValue = 1.0)]
        public double K_ATR { get; set; }
        [Parameter("BodyPct", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = 70, MinValue = 50, MaxValue = 95)]
        public int BodyPct { get; set; }
        [Parameter("Slope EMA20 Min (pips/bar)", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = 1.0, MinValue = 0.0)]
        public double Slope_EMA20_Min_PipsPerBar { get; set; }
        [Parameter("EnableM1MicroPullback", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = true)]
        public bool EnableM1MicroPullback { get; set; }
        [Parameter("PB_MaxPips (M1 micro)", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = 3.0, MinValue = 1.0)]
        public double PB_MaxPips { get; set; }
        [Parameter("M1_MicroBars", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = 3, MinValue = 1, MaxValue = 5)]
        public int M1_MicroBars { get; set; }
        [Parameter("EnableBreakoutFallback", Group = "B) Entradas & Filtros – MomentumSnap", DefaultValue = true)]
        public bool EnableBreakoutFallback { get; set; }
        [Parameter("ATR_Max (pips, 0=OFF)", Group="B) Entradas & Filtros – Básicos", DefaultValue=0.0, MinValue=0.0)]
        public double ATR_Max_Pips { get; set; }
        // =========================
        //   C) SIZING & RIESGO
        // =========================
        [Parameter("RiskPerTradePct", Group = "C) Sizing & Riesgo", DefaultValue = 1.0, MinValue = 0.1, MaxValue = 5.0)]
        public double RiskPerTradePct { get; set; }
        [Parameter("MaxConsecLosses", Group = "C) Sizing & Riesgo", DefaultValue = 2, MinValue = 1, MaxValue = 10)]
        public int MaxConsecLosses { get; set; }
        [Parameter("MaxDailyRiskPct", Group = "C) Sizing & Riesgo", DefaultValue = 3.0, MinValue = 0.5, MaxValue = 10.0)]
        public double MaxDailyRiskPct { get; set; }
        // =========================
        //   D) SALIDAS
        // =========================
        [Parameter("SL_ATR_Mult", Group = "D) Salidas – Stop Loss", DefaultValue = 1.2, MinValue = 0.8, MaxValue = 2.5)]
        public double SL_ATR_Mult { get; set; }
        [Parameter("SL_MinPips", Group = "D) Salidas – Stop Loss", DefaultValue = 3.0, MinValue = 2.0)]
        public double SL_MinPips { get; set; }
        [Parameter("SL_MaxPips", Group = "D) Salidas – Stop Loss", DefaultValue = 9.0, MinValue = 5.0)]
        public double SL_MaxPips { get; set; }
        [Parameter("TP_Mode", Group = "D) Salidas – Take Profits", DefaultValue = "RMultiple")]
        public string TP_Mode { get; set; }
        [Parameter("EnableTP1", Group = "D) Salidas – Take Profits", DefaultValue = true)]
        public bool EnableTP1 { get; set; }
        [Parameter("TP1_R", Group = "D) Salidas – Take Profits", DefaultValue = 1.4, MinValue = 0.8, MaxValue = 4.0)]
        public double TP1_R { get; set; }
        [Parameter("TP1_Pips", Group = "D) Salidas – Take Profits", DefaultValue = 8.0, MinValue = 5.0, MaxValue = 20.0)]
        public double TP1_Pips { get; set; }
        [Parameter("EnableTP2", Group = "D) Salidas – Take Profits", DefaultValue = true)]
        public bool EnableTP2 { get; set; }
        [Parameter("TP2_R", Group = "D) Salidas – Take Profits", DefaultValue = 2.2, MinValue = 1.0, MaxValue = 5.0)]
        public double TP2_R { get; set; }
        [Parameter("TP2_Pips", Group = "D) Salidas – Take Profits", DefaultValue = 12.0, MinValue = 6.0, MaxValue = 30.0)]
        public double TP2_Pips { get; set; }
        [Parameter("PartialCloseTP1Pct", Group = "D) Salidas – Gestión", DefaultValue = 60, MinValue = 0, MaxValue = 100)]
        public int PartialCloseTP1Pct { get; set; }
        [Parameter("BreakEvenAt_R", Group = "D) Salidas – Gestión", DefaultValue = 1.0, MinValue = 0.5, MaxValue = 2.0)]
        public double BreakEvenAt_R { get; set; }
        [Parameter("TrailAfter_R", Group = "D) Salidas – Gestión", DefaultValue = 1.5, MinValue = 1.0, MaxValue = 3.0)]
        public double TrailAfter_R { get; set; }
        [Parameter("TrailStepPips", Group = "D) Salidas – Gestión", DefaultValue = 2.0, MinValue = 1.0, MaxValue = 10.0)]
        public double TrailStepPips { get; set; }
        [Parameter("BE After TP1", Group = "D) Salidas – Gestión", DefaultValue = true)]
        public bool BEAfterTP1 { get; set; }
        [Parameter("BE Pad After TP1 (pips)", Group = "D) Salidas – Gestión", DefaultValue = 0.2, MinValue = 0.0, MaxValue = 5.0)]
        public double BEPadPipsAfterTP1 { get; set; }
        // =========================
        //   E) EJECUCIÓN & OPERATIVA
        // =========================
        [Parameter("Keep Pending Min Bars", Group = "E) Ejecución & Operativa", DefaultValue = 2, MinValue = 0, MaxValue = 10)]
        public int KeepPendingMinBars { get; set; }
        [Parameter("Cancel Consec Bars", Group = "E) Ejecución & Operativa", DefaultValue = 2, MinValue = 1, MaxValue = 10)]
        public int CancelConditionConsecBars { get; set; }
        [Parameter("Cancel Grace (pips)", Group = "E) Ejecución & Operativa", DefaultValue = 0.3, MinValue = 0.0, MaxValue = 5.0)]
        public double CancelGracePips { get; set; }
        [Parameter("Slippage Policy", Group = "E) Ejecución & Operativa", DefaultValue = "Strict")]
        public string SlippagePolicy { get; set; } // "Strict", "Lenient", "Off"
        [Parameter("Slippage Max × ATR", Group = "E) Ejecución & Operativa", DefaultValue = 0.0, MinValue = 0.0, MaxValue = 2.0)]
        public double SlippageMaxAtrMult { get; set; } // 0 = desactivado
        [Parameter("Apply to Market", Group = "E) Ejecución & Operativa", DefaultValue = true)]
        public bool SlippageApplyToMarket { get; set; }
        [Parameter("Apply to Stop", Group = "E) Ejecución & Operativa", DefaultValue = true)]
        public bool SlippageApplyToStop { get; set; }
        [Parameter("Min R After Slippage (Lenient)", Group = "E) Ejecución & Operativa", DefaultValue = 1.20, MinValue = 0.50, MaxValue = 5.0)]
        public double MinRAfterSlip { get; set; }
        [Parameter("Slippage Max (pips)", Group = "E) Ejecución & Operativa", DefaultValue = 0.5, MinValue = 0.0)]
        public double SlippageMaxPips { get; set; }
        [Parameter("EntryBuffer Auto (×ATR)", Group = "E) Ejecución & Operativa", DefaultValue = 0.15, MinValue = 0.0, MaxValue = 1.0)]
        public double EntryBufferAtrMult { get; set; }
        [Parameter("EntryBuffer Min (pips)", Group = "E) Ejecución & Operativa", DefaultValue = 0.8, MinValue = 0.0, MaxValue = 5.0)]
        public double EntryBufferMinPips { get; set; }
        [Parameter("EntryBuffer Max (pips)", Group = "E) Ejecución & Operativa", DefaultValue = 3.0, MinValue = 0.0, MaxValue = 10.0)]
        public double EntryBufferMaxPips { get; set; }
        [Parameter("EntryMode (Market/Stop)", Group = "E) Ejecución & Operativa", DefaultValue = "Stop")]
        public string EntryMode { get; set; }
        [Parameter("EntryBufferPips", Group = "E) Ejecución & Operativa", DefaultValue = 1.0, MinValue = 0.0)]
        public double EntryBufferPips { get; set; }
        [Parameter("MinCloseBeyondPips", Group = "E) Ejecución & Operativa", DefaultValue = 1.5, MinValue = 0.5)]
        public double MinCloseBeyondPips { get; set; }
        [Parameter("CancelPendingsOnRegimeChange", Group = "E) Ejecución & Operativa", DefaultValue = true)]
        public bool CancelPendingsOnRegimeChange { get; set; }
        // =========================
        //   F) MONITOREO
        // =========================
        [Parameter("Cooldown Relax Clean Bars", Group = "F) Monitoreo", DefaultValue = 3, MinValue = 1, MaxValue = 20)]
        public int CooldownRelaxCleanBars { get; set; }
        [Parameter("Day Start Grace Bars", Group = "F) Monitoreo", DefaultValue = 2, MinValue = 0, MaxValue = 20)]
        public int DayStartGraceBars { get; set; }
        [Parameter("ForceCloseAtSessionEnd", Group = "F) Monitoreo", DefaultValue = false)]
        public bool ForceCloseAtSessionEnd { get; set; }
        [Parameter("Slippage Cooldown (min)", Group = "F) Monitoreo", DefaultValue = 5, MinValue = 0, MaxValue = 120)]
        public int SlippageCooldownMin { get; set; }
        [Parameter("CooldownMinutes", Group = "F) Monitoreo", DefaultValue = 10, MinValue = 0, MaxValue = 120)]
        public int CooldownMinutes { get; set; }
        [Parameter("ExitAtSessionEnd", Group = "F) Monitoreo", DefaultValue = true)]
        public bool ExitAtSessionEnd { get; set; }
        [Parameter("Cooldown Flex Enabled", Group = "F) Monitoreo", DefaultValue = true)]
        public bool CooldownFlexEnabled { get; set; }
        [Parameter("Cooldown Decay Bars", Group = "F) Monitoreo", DefaultValue = 2, MinValue = 1, MaxValue = 10)]
        public int CooldownDecayBars { get; set; }
        [Parameter("Cooldown Reset Needs Bars", Group = "F) Monitoreo", DefaultValue = 2, MinValue = 1, MaxValue = 10)]
        public int CooldownResetNeedsBars { get; set; }
        [Parameter("EnableCooldownRelax", Group = "F) Monitoreo", DefaultValue = true)]
        public bool EnableCooldownRelax { get; set; }
        // =========================
        //   Z) META
        // =========================
        [Parameter("Meta – Spread Model",     Group="Z) Backtest Meta", DefaultValue="BT_FIXED_1.5p")]
        public string Meta_SpreadModel { get; set; }
        [Parameter("Meta – Commission Model", Group="Z) Backtest Meta", DefaultValue="USD 7/lot RT")]
        public string Meta_CommissionModel { get; set; }
        [Parameter("Meta – Slippage Model",   Group="Z) Backtest Meta", DefaultValue="Strict, cap=0.5p or 0.2×ATR")]
        public string Meta_SlippageModel { get; set; }
        // =========================
        //   CAMPOS / INDICADORES
        // =========================
        // =======================
        // DAILY AGGREGATION
        // =======================
        // === Flush diario si cambia la fecha (telemetry + daily.csv + reset estado) ===
        private void DailyRollIfDateChange()
        {
            if (Server.Time.Date <= _currentDate) return;

            // 1) volcar el día que termina
            try { _dailyLogger?.Append(_daily, _runId, _currentDate, this); } catch { /* no-op */ }
            // 2) telemetría del día
            _tm?.FlushDay("Daily");
            // 3) reset estado de día
            _currentDate = Server.Time.Date;
            ResetDayHard();
            _barsSinceDayStart = 0;
            PrintTriggerStats("Daily");
            // 4) arrancar agregador del nuevo día
            _daily = new DailyAgg(this, _currentDate);
        }
        
        private sealed class DailyAgg
        {
            private readonly TEMA_Scalper_Levels_MomentumSnap bot;

            public DateTime Day; // fecha que estamos agregando (bot._currentDate)
            // Totales
            public int Trades, Wins, Losses;
            public double NetPips, CumR, MinCumR; // drawdown_R = -MinCumR (si negativo)
            public double ExposureSeconds;
            public double RiskUsedPct;
            public int LongestWin, LongestLose, CurrWin, CurrLose;
            // Cooldowns por motivo
            public readonly Dictionary<string,int> Cooldowns = new(StringComparer.OrdinalIgnoreCase);
            // Por sesión
            private sealed class Sess
            {
                public int Fills;
                public double SumSlipPips;
                public double SumSpreadPips;
                public int Signals; // señales válidas
            }
            private readonly Sess S1 = new(), S2 = new();

            public DailyAgg(TEMA_Scalper_Levels_MomentumSnap botRef, DateTime day)
            {
                bot = botRef; Day = day;
                Trades = Wins = Losses = 0;
                NetPips = CumR = 0.0; MinCumR = 0.0;
                ExposureSeconds = 0.0;
                RiskUsedPct = 0.0;
                LongestWin = LongestLose = CurrWin = CurrLose = 0;
            }

            public void OnValidSignal(DateTime t)
            {
                var s = bot.CurrentSessionId(t);
                if (s == "S1") S1.Signals++;
                else if (s == "S2") S2.Signals++;
            }

            public void OnBar(TimeSpan dt, bool inMarket)
            {
                if (inMarket) ExposureSeconds += Math.Max(0.0, dt.TotalSeconds);
            }

            public void OnTradeOpen(DateTime t, double riskPct, double slipPips, double spreadPips)
            {
                RiskUsedPct += Math.Max(0.0, riskPct);

                var s = bot.CurrentSessionId(t);
                Sess ss = s == "S1" ? S1 : (s == "S2" ? S2 : null);
                if (ss != null)
                {
                    ss.Fills++;
                    ss.SumSlipPips   += slipPips;
                    ss.SumSpreadPips += Math.Abs(spreadPips);
                }
            }

            public void OnCooldown(string reason)
            {
                if (string.IsNullOrWhiteSpace(reason)) reason = "Unspecified";
                Cooldowns[reason] = Cooldowns.TryGetValue(reason, out var v) ? v + 1 : 1;
            }
            // Marca de cooldown aplicado (opcional, por si quieres contarlo como motivo genérico)
            public void OnCooldownApplied() => OnCooldown("Applied");
            // NUEVA firma principal (usada desde OnPositionsClosed)
            public void OnClose(double pnlPips, double r, int duration_bars, bool isWin, bool isLoss)
            {
                Trades++;

                if (isWin)
                {
                    Wins++; CurrWin++; CurrLose = 0;
                    if (CurrWin > LongestWin) LongestWin = CurrWin;
                }
                else if (isLoss)
                {
                    Losses++; CurrLose++; CurrWin = 0;
                    if (CurrLose > LongestLose) LongestLose = CurrLose;
                }
                // Empate/BE: no altera rachas
                NetPips += pnlPips;
                CumR    += r;
                if (CumR < MinCumR) MinCumR = CumR;
            }
            // OVERLOAD retro-compatible (si en algún sitio quedó la firma antigua)
            public void OnClose(double pnlPips, double r, bool isWin)
            {
                OnClose(pnlPips, r, duration_bars: 0, isWin: isWin, isLoss: !isWin);
            }

            private static double SafeDiv(double a, double b) => b != 0.0 ? (a / b) : 0.0;
            // Construye línea CSV con métricas diarias
            public string BuildCsvLine(DateTime day, string runId)
            {
                double wr = SafeDiv(Wins, Wins + Losses) * 100.0;
                double ddR = MinCumR < 0 ? -MinCumR : 0.0;
                // Longitud de sesiones (en horas) para signals/hour
                (DateTime s1a, DateTime s1b) = bot.ParseHHmmInterval(bot.Session1Start, bot.Session1End, day);
                (DateTime s2a, DateTime s2b) = bot.ParseHHmmInterval(bot.Session2Start, bot.Session2End, day);
                double s1Hours = SessionHours(s1a, s1b);
                double s2Hours = SessionHours(s2a, s2b);

                double sigPerHourS1 = SafeDiv(S1.Signals, s1Hours);
                double sigPerHourS2 = SafeDiv(S2.Signals, s2Hours);

                double avgSlipS1   = SafeDiv(S1.SumSlipPips,   S1.Fills);
                double avgSpreadS1 = SafeDiv(S1.SumSpreadPips, S1.Fills);
                double avgSlipS2   = SafeDiv(S2.SumSlipPips,   S2.Fills);
                double avgSpreadS2 = SafeDiv(S2.SumSpreadPips, S2.Fills);
                // Cooldowns concatenados "motivo1:n;motivo2:m"
                string cd = string.Join(";", Cooldowns.Select(kv => $"{kv.Key}:{kv.Value}"));

                string date = day.ToString("yyyy-MM-dd");
                string exposureMin = (ExposureSeconds / 60.0).ToString(bot._invariant);

                return string.Join(",",
                    Escape(runId),
                    Escape(date),
                    Trades.ToString(bot._invariant),
                    Wins.ToString(bot._invariant),
                    Losses.ToString(bot._invariant),
                    wr.ToString("F2", bot._invariant),
                    NetPips.ToString("F2", bot._invariant),
                    CumR.ToString("F2", bot._invariant),
                    ddR.ToString("F2", bot._invariant),
                    exposureMin,
                    RiskUsedPct.ToString("F2", bot._invariant),
                    LongestWin.ToString(bot._invariant),
                    LongestLose.ToString(bot._invariant),
                    Escape(cd),
                    avgSlipS1.ToString("F2", bot._invariant),
                    avgSpreadS1.ToString("F2", bot._invariant),
                    sigPerHourS1.ToString("F2", bot._invariant),
                    avgSlipS2.ToString("F2", bot._invariant),
                    avgSpreadS2.ToString("F2", bot._invariant),
                    sigPerHourS2.ToString("F2", bot._invariant)
                );
            }

            private static double SessionHours(DateTime a, DateTime b)
            {
                // Soporta cruce de medianoche
                if (b >= a) return (b - a).TotalHours;
                return (a.Date.AddDays(1) - a).TotalHours + (b - b.Date).TotalHours;
            }

            private static string Escape(string s)
            {
                s ??= "";
                if (s.Contains(',') || s.Contains('"'))
                    return "\"" + s.Replace("\"", "\"\"") + "\"";
                return s;
            }
        }
        private readonly Dictionary<string, string> _marketOrderIdByLabel = new();

        private sealed class DailyCsvLogger
        {
            private readonly Action<string> log;
            private readonly System.IO.StreamWriter w;
            private bool headerWritten = false;

            public DailyCsvLogger(string baseDir, string runId, Action<string> printer)
            {
                log = printer ?? (_ => { });
                var path = System.IO.Path.Combine(baseDir, $"daily_{runId}.csv");
                try
                {
                    w = new System.IO.StreamWriter(path, append: false, encoding: Encoding.UTF8);
                }
                catch (Exception ex)
                {
                    log($"[ERR][daily.csv open] {ex.Message}");
                    w = null;
                }
                if (w != null) log($"[daily.csv] → {path}");
            }

            private void EnsureHeader()
            {
                if (headerWritten || w == null) return;
                w.WriteLine(string.Join(",",
                    "run_id","date",
                    "trades","wins","losses","wr_pct",
                    "net_pips","net_R","max_drawdown_R",
                    "exposure_minutes","risk_used_pct",
                    "longest_win_streak","longest_lose_streak",
                    "cooldowns",
                    "avg_slippage_pips_S1","avg_spread_pips_S1","signals_per_hour_S1",
                    "avg_slippage_pips_S2","avg_spread_pips_S2","signals_per_hour_S2"
                ));
                headerWritten = true;
            }

            public void Append(DailyAgg agg, string runId, DateTime day, TEMA_Scalper_Levels_MomentumSnap bot)
            {
                if (w == null || agg == null) return;
                EnsureHeader();
                var line = agg.BuildCsvLine(day, runId);
                w.WriteLine(line);
                w.Flush();
            }

            public void Close()
            {
                try { w?.Flush(); w?.Dispose(); } catch { }
            }
        }
        // ===== punto 5: helper para registrar colocación de órdenes =====
        private void RegisterPlacementCommon(
            string orderIdStr,           // po.Id.ToString() para STOP; "MKT:<runId>:<label>" para MARKET
            string signalId,             // <-- úsalo
            string label,
            string typeStr,              // "STOP" | "MARKET"
            bool isBuy,
            double entryPrice,
            double slPips,
            double tpPips,
            double entryBufPips,         // usa _mEntryBufPips o 0 en mercado si no aplica
            bool trendOkAtPlace,
            string boxStateAtPlace       // "re=[H,L];mi=[h,l]" o ""
        )
        {
            // 0) SID final: prioriza el que recibimos; luego el que venga en la etiqueta; y por último genera uno
            string sidFinal = !string.IsNullOrWhiteSpace(signalId)
                ? signalId
                : (ExtractSid(label) ?? GenerateSignalId(CurrentBarIndex(), ExtractTriggerTag(label) ?? "NA", isBuy));

            // 1) Expiración: solo para STOP; MARKET sin expiración
            DateTime? expire = typeStr.Equals("STOP", StringComparison.OrdinalIgnoreCase)
                ? Server.Time.AddMinutes(TriggerTimeoutBars * Policy.TRIGGER_TIMEOUT_SCALE_MIN)
                : (DateTime?)null;

            // 2) orders.csv → fila "placed" con el SID correcto
            _orders?.OnPlaced(
                _runId,
                orderIdStr,
                sidFinal,
                Server.Time,
                typeStr,
                label,
                isBuy ? "BUY" : "SELL",
                entryPrice,
                slPips,
                tpPips,
                entryBufPips,
                expire,
                trendOkAtPlace,
                boxStateAtPlace
            );

            // 3) expected entry para slippage posterior
            _expectedEntryByLabel[label] = entryPrice;

            // 4) tracking “live” solo si es STOP (orderIdStr convertible a long)
            if (typeStr.Equals("STOP", StringComparison.OrdinalIgnoreCase) && long.TryParse(orderIdStr, out var oid))
            {
                _orderIdByLabel[label] = oid;
                _liveById[oid] = new OrderLive {
                    Label = label,
                    IsBuy = isBuy,
                    EntryPrice = entryPrice,
                    BestReachPrice = entryPrice,
                    MinDistPips = double.PositiveInfinity,   // ← útil para métricas de distancia
                    TimePlaced = Server.Time
                };
            }
        }

       // === TRADES LOG ===
        private TradesCsvLogger _trades;
        private readonly Dictionary<long, TradeLegTrack> _openLegs = new(); // pos.Id -> tracking
        // =============== Señales → CSV ===============
        private System.IO.StreamWriter _signalsWriter;
        private bool _signalsHeaderWritten = false;
        // Genera un ID de señal estable dentro del run, sin depender de otras clases
        
        // cache de prechecks del último OnBar (para log de señales)
        private bool _lastNoiseOk = false;
        private bool _lastRegimeOk = false;
        // secuenciador de señales (para ids legibles y ordenados)
        private long _signalSeq = 0;
        // Motivos estandarizados de "skip" (subset del §8)
        // Motivos estandarizados de "skip" (subset del §8)
        private enum RejectCode
        {
            NONE = 0,
            COOLDOWN_ACTIVE,
            SPREAD_HIGH,
            ATR_TOO_LOW,
            ATR_SPIKE,
            ATR_TOO_HIGH,
            OUT_OF_SESSION,
            EMA_TREND_INVALID,
            EMA_SEP_TOO_LOW,
            REENTRY_BLOCKED,
            TRIGGER_COOLING,
            ZONE_NOT_OK,
            MICRO_PB_FAIL,   // << nuevo
            CONS_FAIL,       // << nuevo (consolidación no válida)
            BEYOND_FAIL,     // << nuevo (no supera umbral dinámico)
            PENDING_SAME_SIDE,
            SL_ABOVE_MAX,
            OTHER
        }
        // ── EXIT: motivos de cierre del trade
        private enum ExitReason
        {
            TP1, TP2, SL, BE, TRAIL, FORCE_CLOSE_SESSION, MANUAL, ERROR
        }
        // ── Canonicalizadores a string estable (CSV / logs)
        private static string CanonReject(RejectCode r) => r switch
        {
            RejectCode.COOLDOWN_ACTIVE   => "COOLDOWN_ACTIVE",
            RejectCode.SPREAD_HIGH       => "SPREAD_HIGH",
            RejectCode.ATR_TOO_LOW       => "ATR_TOO_LOW",
            RejectCode.ATR_SPIKE         => "ATR_SPIKE",
            RejectCode.ATR_TOO_HIGH      => "ATR_TOO_HIGH",
            RejectCode.OUT_OF_SESSION    => "OUT_OF_SESSION",
            RejectCode.EMA_TREND_INVALID => "EMA_TREND_INVALID",
            RejectCode.EMA_SEP_TOO_LOW   => "EMA_SEP_TOO_LOW",
            RejectCode.REENTRY_BLOCKED   => "REENTRY_BLOCKED",
            RejectCode.TRIGGER_COOLING   => "TRIGGER_COOLING",
            RejectCode.ZONE_NOT_OK       => "ZONE_NOT_OK",   // ← corregido
            RejectCode.MICRO_PB_FAIL     => "MICRO_PB_FAIL",
            RejectCode.CONS_FAIL         => "CONS_FAIL",
            RejectCode.BEYOND_FAIL       => "BEYOND_FAIL",
            RejectCode.PENDING_SAME_SIDE => "PENDING_SAME_SIDE",
            RejectCode.SL_ABOVE_MAX      => "SL_ABOVE_MAX",
            _                            => "OTHER"
        };

        private static string CanonCancel(TelemetryFunnel.CancelReason r) => r switch
        {
            TelemetryFunnel.CancelReason.RegimeChange       => "REGIME_CHANGE",
            TelemetryFunnel.CancelReason.FBKMacroInvalid    => "FBK_INVALIDATED",
            TelemetryFunnel.CancelReason.MicroBoxTooWide    => "MICRO_BOX_TOO_WIDE",
            TelemetryFunnel.CancelReason.TwoOppClosesBeyond => "TWO_OPP_CLOSES_BEYOND",
            TelemetryFunnel.CancelReason.Timeout            => "EXPIRED_TIMEOUT",
            TelemetryFunnel.CancelReason.SessionEnd         => "SESSION_END",
            TelemetryFunnel.CancelReason.SlippageAdverse    => "SLIPPAGE_ADVERSE",
            TelemetryFunnel.CancelReason.Manual             => "MANUAL",
            TelemetryFunnel.CancelReason.BotStop            => "BOT_STOP",
            TelemetryFunnel.CancelReason.TrendMisalign      => "TREND_MISALIGNED",
            _                                               => "OTHER"
        };

        private static string CanonExit(ExitReason r) => r switch
        {
            ExitReason.TP1                 => "TP1",
            ExitReason.TP2                 => "TP2",
            ExitReason.SL                  => "SL",
            ExitReason.BE                  => "BE",
            ExitReason.TRAIL               => "TRAIL",
            ExitReason.FORCE_CLOSE_SESSION => "FORCE_CLOSE_SESSION",
            ExitReason.MANUAL              => "MANUAL",
            _                              => "ERROR"
        };

        private int _cooldownCleanStreak = 0;
        // Reentrancy guard para la gestión
        private bool _inManage = false;

        // Tracking de pendings (por Id y por Label) para edad y rachas de "inválido"
        private readonly Dictionary<long, int> _poPlacedAtBarById      = new Dictionary<long, int>();
        private readonly Dictionary<string, int> _poPlacedAtBarByLabel = new Dictionary<string, int>(StringComparer.Ordinal);

        private readonly Dictionary<long, int> _poInvalidStreakById      = new Dictionary<long, int>();
        private readonly Dictionary<string, int> _poInvalidStreakByLabel = new Dictionary<string, int>(StringComparer.Ordinal);

        // Métricas cacheadas por barra M5
        private int _metricsBarIndex = -1;
        private double _mO, _mC, _mH, _mL;
        private double _mAtrPips;
        private double _mRangePips;
        private double _mBodyPct;
        private double _mEma20SlopePips;

        private ExponentialMovingAverage _emaFast, _emaMed, _emaSlow;
        private AverageTrueRange _atr;
        private Bars _barsM5 => Bars; // TF principal
        private Bars _barsD1;
        private Bars _barsM1;
        private int _lastSignalBarIndex = -1;
        private bool _signalFiredThisBar = false;
        // Slippage esperado por etiqueta
        private readonly Dictionary<string, double> _expectedEntryByLabel = new Dictionary<string, double>();

        private readonly Dictionary<string, (double high, double low, int calculatedAt)> _boxCache
            = new Dictionary<string, (double high, double low, int calculatedAt)>();

        // Contadores de rechazo
        private int _rejSpread = 0;
        private int _rejATR = 0;
        private int _rejTrend = 0;
        private int _rejProximity = 0;
       // Anti-reentrada por rango (box)
        private bool _blockLong = false, _blockShort = false;
        private double _blockHigh = double.NaN, _blockLow = double.NaN;
        private int _blockUntilBar = -1;
        // Histeresis
        private bool _spreadOkPrev = true;
        private bool _atrOkPrev = true;
        // Cap efectivo de slippage en pips: max(pips fijos, xATR) si ambos están activos.
        private double SlipCapPips(double atrPips)
        {
            double capPips = (SlippageMaxPips > 0) ? SlippageMaxPips : 0.0;
            if (SlippageMaxAtrMult > 0 && atrPips > 0)
                capPips = Math.Max(capPips, SlippageMaxAtrMult * atrPips);
            return capPips; // 0 => sin cap
        }
        // ¿slippage adverso?
        private bool IsAdverseSlip(bool isBuy, double slipPips)
        {
            // Para Buy, slip>0 es adverso (entras más caro). Para Sell, slip>0 es favorable.
            return isBuy ? (slipPips > 0) : (slipPips < 0);
        }
        // Niveles del día
        private double? _PDH, _PDL, _AsiaH, _AsiaL;
        private DateTime _currentDate;
        private bool _inRegimePrev = false;
        // Control riesgo/racha
        private int _consecLosses = 0;
        private double _riskTodayPct = 0.0;
        private DateTime _cooldownUntil = DateTime.MinValue;
        // Extremos deslizantes por índice para cajas
        private MonoMax _mxReentryHigh, _mxMicroHigh;
        private MonoMin _mnReentryLow,  _mnMicroLow;
        private int _reentryWin, _microWin;

        // Cooldown por trigger
        private readonly Dictionary<string, int> _trigCooldownUntil = new Dictionary<string, int>
        {
            {"BOS", -1}, {"ENG", -1}, {"PIN", -1}, {"FBK", -1}, {"MOM", -1}
        };
        // Constantes del símbolo
        private double _pipSize;
        private double _pipToPrice;
        private double _priceToPipsFactor;
        private double _unitsPerLot;

        private double PointsToPips(double points) => points * _priceToPipsFactor;
        private double PriceToPips(double priceDiff) => priceDiff * _priceToPipsFactor;
        private double PipsToPrice(double pips) => pips * _pipToPrice;
        private double _mEntryBufPips;
        // ---- Cola/flags para orquestar estado desde OnBar (single-writer) ----
        private int _pendingReentry = 0;              // +1 = bloquear reentrada long, -1 = short, 0 = nada
        private bool _pendingCancelPendings = false;  // pedir cancelar pendientes
        private DateTime _pendingCooldownUntil = DateTime.MinValue; // cooldown solicitado (se aplicará si es > _cooldownUntil)
        // Motivo a usar cuando se piden cancelaciones masivas
        private TelemetryFunnel.CancelReason _pendingCancelReason = TelemetryFunnel.CancelReason.Manual;
        // Sobrecarga: pedir cancelación de pendings con motivo
        private void RequestCancelAllPendings(TelemetryFunnel.CancelReason reason)
        {
            _pendingCancelPendings = true;
            _pendingCancelReason = reason;
        }
        // Conserva el nombre anterior para compatibilidad interna
        private void RequestCancelAllPendings()
        {
            RequestCancelAllPendings(TelemetryFunnel.CancelReason.Manual);
        }
        // Helper: pedir cooldown monotónico
        private void RequestCooldownUntil(DateTime until)
        {
            if (until > _pendingCooldownUntil) _pendingCooldownUntil = until;
        }

        // Helper: pedir bloqueo de reentrada
        private void RequestReentryBlock(bool wasLong)
        {
            _pendingReentry = wasLong ? 1 : -1;
        }
       
        private struct BarMetrics
        {
            public double O, C, H, L;
            public double AtrPips, RangePips, BodyPct;
            public double Ema20SlopePips, EntryBufPips;
            public bool IsValid;
        }
        // Contexto de barra (para triggers declarativos)
        private sealed class BarCtx
        {
            public int I { get; }
            public double O { get; }
            public double C { get; }
            public double H { get; }
            public double L { get; }
            public double AtrPips { get; }
            public double RangePips { get; }
            public double BodyPct { get; }
            public double Ema20SlopePips { get; }
            public double EntryBufPips { get; }
            public bool TrendUp { get; }
            public bool TrendDown { get; }

            public BarCtx(int i, double o, double c, double h, double l,
                          double atr, double range, double bodyPct,
                          double ema20Slope, double entryBuf, bool up, bool dn)
            {
                I=i; O=o; C=c; H=h; L=l;
                AtrPips=atr; RangePips=range; BodyPct=bodyPct;
                Ema20SlopePips=ema20Slope; EntryBufPips=entryBuf;
                TrendUp=up; TrendDown=dn;
            }
        }
        // Cache de métricas por índice de barra
        private readonly Dictionary<int, BarMetrics> _metricsCache = new Dictionary<int, BarMetrics>(500);
        // Contadores de señales por trigger
        private readonly Dictionary<string, int> _sigCount = new Dictionary<string, int>
        {
            {"BOS", 0}, {"ENG", 0}, {"PIN", 0}, {"FBK", 0}, {"MOM", 0}
        };

        private int _barsSeen = 0, _barsPassedNoise = 0, _barsPassedRegime = 0;

        private readonly Dictionary<string, int> _winCount  = new Dictionary<string, int> {{"BOS",0},{"ENG",0},{"PIN",0},{"FBK",0},{"MOM",0}};
        private readonly Dictionary<string, int> _lossCount = new Dictionary<string, int> {{"BOS",0},{"ENG",0},{"PIN",0},{"FBK",0},{"MOM",0}};
        private readonly Dictionary<string, double> _pnlPerTag = new Dictionary<string, double> {{"BOS",0},{"ENG",0},{"PIN",0},{"FBK",0},{"MOM",0}};
        private int _barsSinceDayStart = 0;
        private int _blockStartBar = -1;
        // ===============================================
        //  POLÍTICA (centraliza "magic numbers")
        // ===============================================
        private static class Policy
        {
            // Histeresis / ATR
            public const double SPREAD_HYST_MARGIN_PIPS = 0.10;
            public const double ATR_HYST_MARGIN_PIPS    = 0.10;
            public const int    ATR_SPIKE_LOOKBACK      = 20;
            public const double ATR_SPIKE_FACTOR        = 2.0;
            public const double SAFEATR_SANITY_MAX_PIPS = 500.0;
            // Breakouts y consolidación
            public const double DYN_CLOSE_BEYOND_ATR_BOS = 0.25; // 25% ATR (BOS micro)
            public const double DYN_CLOSE_BEYOND_ATR_FBK = 0.20; // 20% ATR (fallback / macro)
            public const double CONS_RANGE_MULT_BOS      = 0.60; // caja <= 0.60*ATR
            public const double CONS_RANGE_MULT_FBK      = 0.70; // caja <= 0.70*ATR
            public const int    BOS_CONS_LB_MAX          = 3;    // velas p/consolidación BOS
            public const int    FBK_CONS_LB_MAX          = 5;    // velas p/consolidación FBK
            // --- SL estructural por swings ---
            public const int    SL_SWING_LOOKBACK_BARS   = 20;   // ventana para buscar swing
            public const int    SL_SWING_CONFIRM_K       = 2;    // k izq/der para confirmar mínimo/máximo local
            public const double SL_STRUCT_EXTRA_PAD_PIPS = 0.0;  // pad adicional opcional sobre STRUCT_SL_PAD_PIPS
            // Banda EMA / proximidad
            public const double NEAR_EMA_BAND_MAX_PIPS   = 3.0;
            public const double NEAR_EMA_BAND_ATR_MULT   = 0.40;
            // Patrones velas
            public const int    ENG_BODY_FLOOR_PCT       = 70;   // suelo p/engulfing (se aplica con BodyPct)
            public const double ENG_RANGE_MIN_ATR_MULT   = 0.60; // rango mínimo relativo al ATR
            public const double PIN_WICK_TO_BODY_MIN     = 2.0;
            public const double PIN_RANGE_MIN_ATR_MULT   = 0.50;
            // Stops / TPs
            public const double STRUCT_SL_PAD_PIPS       = 1.0;  // colchón estructural extra
            public const double TP1_MIN_PIPS             = 5.0;
            public const double TP2_MIN_PIPS             = 6.0;
            public const double TP_CAP_PIPS              = 15.0;
            // PlaceStopOrder expiration
            public const int    TRIGGER_TIMEOUT_SCALE_MIN = 5;   // minutos por "bar" de timeout

            // Limpieza de caches
            public const int    METRICS_CACHE_PRUNE_IF_GT = 1000;
            public const int    METRICS_CACHE_KEEP_BACK   = 500;
            public const int    BOX_CACHE_PRUNE_IF_GT     = 800;
            public const int    BOX_CACHE_TRIM_BATCH      = 300;
            // si la micro-box supera el 80% del límite permitido → sumamos buffer extra
            public const double MICROBOX_WIDE_FRAC_OF_LIMIT = 0.80; 
            public const int    SPREAD_MED_WINDOW_BARS = 12;   // ~1h en M5
            public const double SPREAD_SPIKE_MED_MULT  = 2.0;  // “spike” si ahora > 2× mediana
        }

        private static double Clamp(double lo, double hi, double v) => Math.Max(lo, Math.Min(hi, v));
        private static int    ClampInt(int lo, int hi, int v)      => Math.Max(lo, Math.Min(hi, v));
                     

        private void ApplyProfile(string profile, int trigAgg, int structStrict, int execStrict, int riskProf)
        {
            // Normaliza entradas
            trigAgg      = Math.Max(0, Math.Min(2, trigAgg));
            structStrict = Math.Max(0, Math.Min(2, structStrict));
            execStrict   = Math.Max(0, Math.Min(2, execStrict));
            riskProf     = Math.Max(0, Math.Min(2, riskProf));

            bool CONS = profile.Equals("Conservative", StringComparison.OrdinalIgnoreCase);
            bool AGGR = profile.Equals("Aggressive",   StringComparison.OrdinalIgnoreCase);
            // Balanced si no coincide
            // ---- 1) Gatillos (agresividad)
            ConfirmBars              = ClampInt(1, 3, (CONS ? 2 : 1) + (trigAgg == 0 ? 1 : 0));
            TriggerCooldownBars      = ClampInt(0, 10, (CONS ? 5 : 3) - trigAgg);
            MinCloseBeyondPips       = Clamp(0.5, 3.0, (CONS ? 2.0 : 1.5) - 0.2 * trigAgg);
            MicroBoxMaxRangeAtrMult  = Clamp(0.4, 2.0, 0.8 + 0.2 * (2 - trigAgg));
            MicroBoxOppBeyondAtrMult = Clamp(0.10,0.50, 0.22 + 0.04 * (1 - trigAgg));
            // ---- 2) Estructura (cancelaciones)
            KeepPendingMinBars        = ClampInt(0, 5,  CONS ? 3 : (structStrict >= 2 ? 1 : 2));
            CancelConditionConsecBars = ClampInt(1, 4,  CONS ? 2 : (structStrict >= 2 ? 1 : 2));
            CancelGracePips           = Clamp(0.0, 1.0, 0.15 + 0.05 * (2 - structStrict));
            // ---- 3) Ejecución (spread/slippage/cooldown)
            SpreadMaxPips       = Clamp(0.1, 1.0, (CONS ? 0.25 : 0.35) + 0.05 * (1 - execStrict));
            SlippageMaxPips     = Clamp(0.1, 2.0, (CONS ? 0.4 : 0.6) + 0.2 * (1 - execStrict));
            SlippageCooldownMin = ClampInt(0, 30, (CONS ? 7 : 5) + (execStrict == 0 ? 3 : 0));
            CooldownMinutes     = ClampInt(0,120, (CONS ? 15 : 10) + (execStrict == 0 ? 10 : 0));
            // ---- 4) Riesgo (tp/breakeven/trailing)
            RiskPerTradePct  = Clamp(0.2, 2.5, 0.6 + 0.4 * riskProf);  // 0.6,1.0,1.4
            BreakEvenAt_R    = Clamp(0.5, 2.0, (CONS ? 0.8 : 1.0) - 0.1 * riskProf);
            TrailAfter_R     = Clamp(1.0, 3.0, (CONS ? 1.8 : 1.5) - 0.2 * riskProf);
            TrailStepPips    = Clamp(1.0,10.0, (CONS ? 2.5 : 2.0));
            // ---- 5) Buffers de entrada
            EntryBufferAtrMult = Clamp(0.0, 1.0, 0.12 + 0.03 * (2 - trigAgg));
            EntryBufferMinPips = Clamp(0.5, 2.0, 0.8);
            EntryBufferMaxPips = Clamp(1.5, 5.0, 3.0);
            // ---- 6) Reentrada (bloqueos)
            ReentryBlockBars           = ClampInt(0, 100, CONS ? 12 : 10);
            ReentryAutoUnblockBars     = ClampInt(0, 200, (AGGR ? 8 : 12) - trigAgg);
            ReentryDriftUnblockAtrMult = Clamp(0.2, 3.0, 1.0 - 0.2 * trigAgg);
            // ---- 7) Zonas por defecto (coherentes)
            ZonePolicy_BOS = ZonePolicy_BOS ?? "Either";
            ZonePolicy_FBK = ZonePolicy_FBK ?? "Either";
            ZonePolicy_ENG = ZonePolicy_ENG ?? "EMA";
            ZonePolicy_PIN = ZonePolicy_PIN ?? "EMA";
            ZonePolicy_MOM = ZonePolicy_MOM ?? "EMA";
        }
        // --- Telemetría (embudo) ---
        private TelemetryFunnel _tm;
        private RunAgg _runAgg;
        // =====================================================
        // PUNTO 7: Agregador de métricas del RUN (por Trigger y Regímenes)
        // =====================================================
        private sealed class RunAgg
        {
            private readonly TEMA_Scalper_Levels_MomentumSnap bot;

            // ---- helpers numéricos ----
            static double Mean(IList<double> xs) => (xs == null || xs.Count == 0) ? 0.0 : xs.Sum() / xs.Count;
            static double StdDev(IList<double> xs)
            {
                if (xs == null || xs.Count < 2) return 0.0;
                double m = Mean(xs);
                double v = xs.Sum(x => (x - m) * (x - m)) / (xs.Count - 1);
                return Math.Sqrt(Math.Max(0.0, v));
            }
            static double DownsideDev(IList<double> xs)
            {
                if (xs == null || xs.Count == 0) return 0.0;
                var neg = xs.Where(x => x < 0).ToList();
                if (neg.Count == 0) return 0.0;
                double m = 0.0; // target = 0
                double v = neg.Sum(x => (x - m) * (x - m)) / neg.Count;
                return Math.Sqrt(Math.Max(0.0, v));
            }
            static double SafeDiv(double a, double b) => b != 0.0 ? a / b : 0.0;

            static double[] Quantiles(IList<double> xs) // q25,q50,q75
            {
                var v = (xs ?? new List<double>()).Where(d => !double.IsNaN(d) && !double.IsInfinity(d)).OrderBy(d => d).ToList();
                if (v.Count == 0) return new[] { 0.0, 0.0, 0.0 };
                double Q(double p)
                {
                    if (v.Count == 1) return v[0];
                    double idx = (v.Count - 1) * p;
                    int lo = (int)Math.Floor(idx), hi = (int)Math.Ceiling(idx);
                    if (lo == hi) return v[lo];
                    double w = idx - lo;
                    return v[lo] * (1 - w) + v[hi] * w;
                }
                return new[] { Q(0.25), Q(0.50), Q(0.75) };
            }
            // ---- contexto por posición (para buckets al cerrar) ----
            private sealed class Ctx
            {
                public string Tag;          // BOS/ENG/PIN/FBK/MOM
                public double Atr;          // en pips
                public double Slope;        // ema20 slope pips/bar
                public string SessionId;    // S1/S2/OFF/S12
                public int DoW;             // 0..6
                public int HourBin;         // 0..23 (o lo que uses)
                public bool NearLevel;      // proximidad a nivel al fill
                public DateTime PlacedTime; // para time-to-fill
            }
            private readonly Dictionary<long, Ctx> _ctxByPosId = new();
            // ---- por tag (Trigger) ----
            private sealed class TagAgg
            {
                public string Tag;
                public int Placed, Filled, Wins, Losses;
                public List<double> R = new();         // pnl en R por trade
                public List<double> MAE = new();
                public List<double> MFE = new();
                public List<double> TTFsec = new();    // time-to-fill en segundos
                public Dictionary<string,int> Cancels = new(StringComparer.OrdinalIgnoreCase);
            }
            private readonly Dictionary<string, TagAgg> _byTag =
                new(StringComparer.OrdinalIgnoreCase)
                { {"BOS", new TagAgg{Tag="BOS"}}, {"ENG", new TagAgg{Tag="ENG"}},
                  {"PIN", new TagAgg{Tag="PIN"}}, {"FBK", new TagAgg{Tag="FBK"}}, {"MOM", new TagAgg{Tag="MOM"}} };

            // ---- buckets globales (regímenes) ----
            private readonly List<double> _atrSamples   = new();
            private readonly List<double> _slopeSamples = new();

            private sealed class BucketStat { public int N; public int Wins; public double SumR; }
            private readonly BucketStat[] _atrBuck = { new(), new(), new(), new() };   // <=q25,(q25..q50],(q50..q75],>q75
            private readonly BucketStat[] _slopeBuck = { new(), new(), new(), new() };

            private readonly Dictionary<string, BucketStat> _bySession = new(StringComparer.OrdinalIgnoreCase)
                { {"S1",new()}, {"S2",new()}, {"S12",new()}, {"OFF",new()} };
            private readonly Dictionary<int, BucketStat> _byDoW = Enumerable.Range(0,7).ToDictionary(k => k, _ => new BucketStat());
            private readonly Dictionary<int, BucketStat> _byHour = Enumerable.Range(0,24).ToDictionary(k => k, _ => new BucketStat());
            private readonly Dictionary<string, BucketStat> _byNearLevel = new(StringComparer.OrdinalIgnoreCase)
                { {"Near", new BucketStat()}, {"Far", new BucketStat()} };

            public RunAgg(TEMA_Scalper_Levels_MomentumSnap b) { bot = b; }

            public void OnOrderPlaced(string tag)
            {
                if (string.IsNullOrWhiteSpace(tag)) tag = "NA";
                if (_byTag.TryGetValue(tag, out var t)) t.Placed++;
            }

            public void OnOrderCanceled(string tag, string reason)
            {
                if (string.IsNullOrWhiteSpace(tag)) tag = "NA";
                if (!_byTag.TryGetValue(tag, out var t)) return;
                reason = string.IsNullOrWhiteSpace(reason) ? "UNKNOWN" : reason;
                t.Cancels[reason] = t.Cancels.TryGetValue(reason, out var v) ? v + 1 : 1;
            }
            // Llamar en OnPositionOpened
            public void OnFill(long posId, string tag, DateTime placedTime,
                               double atrPips, double slopePipsPerBar, string sessionId, int dow, int hourBin, bool nearLevel, double timeToFillSec)
            {
                if (string.IsNullOrWhiteSpace(tag)) tag = "NA";
                if (_byTag.TryGetValue(tag, out var t))
                {
                    t.Filled++;
                    if (timeToFillSec >= 0) t.TTFsec.Add(timeToFillSec);
                }

                _ctxByPosId[posId] = new Ctx {
                    Tag = tag, Atr = atrPips, Slope = slopePipsPerBar,
                    SessionId = sessionId ?? "OFF", DoW = dow, HourBin = hourBin,
                    NearLevel = nearLevel, PlacedTime = placedTime
                };
            }
            // Llamar en OnPositionsClosed
            public void OnClose(long posId, double pnlR, double maePips, double mfePips, bool isWin)
            {
                if (!_ctxByPosId.TryGetValue(posId, out var cx)) return;
                if (!_byTag.TryGetValue(cx.Tag, out var t)) return;

                if (isWin) t.Wins++; else t.Losses++;
                t.R.Add(pnlR);
                if (!double.IsNaN(maePips)) t.MAE.Add(maePips);
                if (!double.IsNaN(mfePips)) t.MFE.Add(mfePips);
                // muestras para cuartiles globales
                if (cx.Atr > 0) _atrSamples.Add(cx.Atr);
                _slopeSamples.Add(cx.Slope);
                // guardamos para buckets/regímenes; los valores exactos se bucketizan al imprimir
                // Para no perder info, actualizamos estructuras básicas aquí (se recalcularán con cuartiles)
                Acc(_bySession, cx.SessionId, isWin, pnlR);
                Acc(_byDoW, cx.DoW, isWin, pnlR);
                Acc(_byHour, cx.HourBin, isWin, pnlR);
                Acc(_byNearLevel, cx.NearLevel ? "Near" : "Far", isWin, pnlR);

                _ctxByPosId.Remove(posId);
            }

            private static void Acc<TKey>(IDictionary<TKey, BucketStat> dict, TKey k, bool isWin, double r)
            {
                if (!dict.TryGetValue(k, out var b)) return;
                b.N++; if (isWin) b.Wins++; b.SumR += r;
            }

            public void PrintFinalReport()
            {
                bot.Print("──────── RUN SUMMARY (por Trigger)");
                foreach (var kv in _byTag)
                {
                    var t = kv.Value;
                    int trades = t.Wins + t.Losses;
                    double wr = SafeDiv(t.Wins, trades) * 100.0;
                    double avgR = Mean(t.R);
                    double sdR  = StdDev(t.R);
                    double ddR  = DownsideDev(t.R);
                    double sharpe  = sdR > 0 ? (avgR / sdR) : 0.0;
                    double sortino = ddR > 0 ? (avgR / ddR) : 0.0;
                    double avgMAE = Mean(t.MAE);
                    double avgMFE = Mean(t.MFE);
                    double fillRate = SafeDiv(t.Filled, Math.Max(1, t.Placed)) * 100.0;
                    double avgTTF = Mean(t.TTFsec);

                    bot.Print($"[{t.Tag}] Trades={trades} WR={wr:F1}% AvgR={avgR:F2} Sharpe={sharpe:F2} Sortino={sortino:F2} | AvgMAE={avgMAE:F2}p AvgMFE={avgMFE:F2}p | Placed={t.Placed} Filled={t.Filled} FillRate={fillRate:F1}% AvgTTF={avgTTF:F1}s");

                    if (t.Cancels.Count > 0)
                    {
                        var top = t.Cancels.OrderByDescending(x => x.Value).Take(5).Select(x => $"{x.Key}:{x.Value}").ToArray();
                        bot.Print($"   Cancels: {string.Join(", ", top)}");
                    }
                }
                // ─── Buckets globales ───
                var qAtr = Quantiles(_atrSamples);
                var qSlp = Quantiles(_slopeSamples);
                // reseteo y recomputo de buckets (necesitan cuartiles)
                foreach (var b in _atrBuck) { b.N=0; b.Wins=0; b.SumR=0; }
                foreach (var b in _slopeBuck) { b.N=0; b.Wins=0; b.SumR=0; }
                // Necesitamos recontar por bucket: tomamos las muestras ya registradas en _ctxByPosId? No; usamos _atrSamples/_slopeSamples
                // Para poder llevar R/WR por bucket, hemos ido acumulando por sesión/DoW/hour/near; para ATR/slope lo aproximamos con media global
                // Opcional: si quisieras R por bucket exacto, guarda por trade (atr,slope,r,win) en listas paralelas.

                bot.Print($"──────── Buckets ATR (q25={qAtr[0]:F2}p, q50={qAtr[1]:F2}p, q75={qAtr[2]:F2}p) — muestras={_atrSamples.Count}");
                if (_atrSamples.Count > 0)
                {
                    int[] c = new int[4];
                    foreach (var a in _atrSamples)
                        c[ (a <= qAtr[0]) ? 0 : (a <= qAtr[1]) ? 1 : (a <= qAtr[2]) ? 2 : 3 ]++;
                    bot.Print($"   <=q25:{c[0]} | (q25..q50]:{c[1]} | (q50..q75]:{c[2]} | >q75:{c[3]}");
                }

                bot.Print($"──────── Buckets Slope EMA20 (q25={qSlp[0]:F2}, q50={qSlp[1]:F2}, q75={qSlp[2]:F2}) — muestras={_slopeSamples.Count}");
                if (_slopeSamples.Count > 0)
                {
                    int[] c = new int[4];
                    foreach (var s in _slopeSamples)
                        c[ (s <= qSlp[0]) ? 0 : (s <= qSlp[1]) ? 1 : (s <= qSlp[2]) ? 2 : 3 ]++;
                    bot.Print($"   <=q25:{c[0]} | (q25..q50]:{c[1]} | (q50..q75]:{c[2]} | >q75:{c[3]}");
                }
                // Sesión / DoW / Hour / Proximidad a nivel
                bot.Print("──────── Regímenes");
                foreach (var kv in _bySession)
                {
                    var b = kv.Value; double wr = SafeDiv(b.Wins, b.N) * 100.0; double avgR = SafeDiv(b.SumR, b.N);
                    bot.Print($"   Session {kv.Key}: N={b.N} WR={wr:F1}% AvgR={avgR:F2}");
                }
                foreach (var kv in _byDoW.Where(kv => kv.Value.N > 0).OrderBy(kv => kv.Key))
                {
                    var b = kv.Value; double wr = SafeDiv(b.Wins, b.N) * 100.0; double avgR = SafeDiv(b.SumR, b.N);
                    bot.Print($"   DoW {kv.Key}: N={b.N} WR={wr:F1}% AvgR={avgR:F2}");
                }
                var hours = _byHour.Where(kv => kv.Value.N > 0).OrderBy(kv => kv.Key).ToList();
                if (hours.Count > 0)
                {
                    bot.Print("   Hour bins:");
                    foreach (var kv in hours)
                    {
                        var b = kv.Value; double wr = SafeDiv(b.Wins, b.N) * 100.0; double avgR = SafeDiv(b.SumR, b.N);
                        bot.Print($"      H{kv.Key:00}: N={b.N} WR={wr:F1}% AvgR={avgR:F2}");
                    }
                }
                foreach (var kv in _byNearLevel)
                {
                    var b = kv.Value; double wr = SafeDiv(b.Wins, b.N) * 100.0; double avgR = SafeDiv(b.SumR, b.N);
                    bot.Print($"   NearLevel={kv.Key}: N={b.N} WR={wr:F1}% AvgR={avgR:F2}");
                }
            }
        }
       // === ORDERS CSV (estado runtime) ===
        private OrdersCsvLogger _orders;
        // Tracking de “live stats” para pendientes (mejor alcance y min distancia a entry)
        private sealed class OrderLive
        {
            public string Label;
            public bool IsBuy;
            public double EntryPrice;
            public double MinDistPips = double.PositiveInfinity;
            public double BestReachPrice; // max si Buy, min si Sell
            public DateTime TimePlaced;
        }
        private readonly Dictionary<long, OrderLive> _liveById = new();
        
        private readonly Dictionary<string, long> _orderIdByLabel = new(StringComparer.Ordinal);
        // Prioridad de triggers declarativa
        private static readonly string[] TriggerPriority = { "BOS", "ENG", "PIN", "FBK" };
      
        private string PickTrigger(bool up, int i)
        {
            foreach (var t in TriggerPriority)
            {
                if (IsTriggerCooling(t)) continue;

                switch (t)
                {
                    case "BOS":
                        if (EnableTrigger_BOSmicro && IsBOSMicro(up, BOS_MicroBars)) return "BOS";
                        break;
                    case "ENG":
                        if (EnableTrigger_Engulfing && IsEngulfing(up)) return "ENG";
                        break;
                    case "PIN":
                        if (EnableTrigger_PinBar && IsPinBar(up, PinBarWickPct)) return "PIN";
                        break;
                    case "FBK":
                        if (EnableBreakoutFallback && IsFallbackBreakoutValid(i, up)) return "FBK";
                        break;
                }
            }
            return null;
        }
        // Infra de triggers declarativos (extensible)
        private interface ITrigger
        {
            string Code { get; } // "BOS", "ENG", "PIN", "FBK", "MOM"
            bool Enabled { get; }
            bool CoolingOk(int i, Func<string,bool> isCooling);
            bool Match(BarCtx ctx);
            bool ZoneOk(BarCtx ctx);
        }
        // === SID helpers ===
        // ===== SID helpers (única copia) =====
        private string GenerateSignalId(int barIndex, string trigTag, bool up)
            => $"{_runId}:{barIndex}:{(up ? "L" : "S")}:{(trigTag ?? "NA")}";

        private static string WithSid(string label, string sid)
            => string.IsNullOrEmpty(sid) ? label : $"{label} SID={sid}";

        private static string ExtractSid(string label)
        {
            if (string.IsNullOrEmpty(label)) return null;
            int k = label.IndexOf("SID=", StringComparison.OrdinalIgnoreCase);
            if (k < 0) return null;
            int start = k + 4;
            int end = label.IndexOf(' ', start);
            return (end >= 0 ? label.Substring(start, end - start) : label.Substring(start)).Trim();
        }
       
        private sealed class TriggerBOS : ITrigger
        {
            private readonly TEMA_Scalper_Levels_MomentumSnap bot;
            public string Code => "BOS";
            public bool Enabled => bot.EnableTrigger_BOSmicro;
            public TriggerBOS(TEMA_Scalper_Levels_MomentumSnap b) { bot=b; }

            public bool CoolingOk(int i, Func<string,bool> isCooling) => !isCooling(Code);
            public bool Match(BarCtx ctx) => bot.IsBOSMicro(ctx.TrendUp, bot.BOS_MicroBars);
            public bool ZoneOk(BarCtx ctx) => bot.ZoneOk(Code, ctx.I, ctx.C);
        }
        // (Reservado para ampliar familia de triggers)
        private List<ITrigger> _trigs;
        private void InitTriggers()
        {
            _trigs = new List<ITrigger> {
                new TriggerBOS(this),
                // new TriggerEng(this), new TriggerPin(this),
                // new TriggerFBK(this), new TriggerMOM(this)
            };
        }

        private bool IsFallbackBreakoutValid(int i, bool up)
        {
            double atrPipsFBK = SafeAtrPips(i);
            if (atrPipsFBK <= 0) return false;

            var (boxHigh, boxLow, boxRangePips, consolidated) =
                ConsolidationBox(
                    i,
                    Policy.FBK_CONS_LB_MAX,
                    atrPipsFBK,
                    Policy.CONS_RANGE_MULT_FBK,
                    Policy.FBK_CONS_LB_MAX
                );
            if (!consolidated) return false;

            double refLevel   = up ? boxHigh : boxLow;
            double close      = _barsM5.ClosePrices[i];
            double beyondPips = PriceToPips(Math.Abs(close - refLevel));

            double dynMin = DynMinBeyond(atrPipsFBK, Policy.DYN_CLOSE_BEYOND_ATR_FBK);
            return beyondPips >= dynMin;
        }

        private BarCtx BuildBarCtx(int i)
        {
            RefreshBarMetrics(i);
            if (_mAtrPips <= 0) return null;

            double emaF = _emaFast.Result[i], emaM = _emaMed.Result[i], emaS = _emaSlow.Result[i];
            bool up = emaF > emaM && emaM > emaS;
            bool dn = emaF < emaM && emaM < emaS;

            return new BarCtx(i, _mO, _mC, _mH, _mL, _mAtrPips, _mRangePips, _mBodyPct,
                              _mEma20SlopePips, _mEntryBufPips, up, dn);
        }
       // Helper: mínimo dinámico "close beyond" en función del ATR
        private double DynMinBeyond(double atrPips, double factorAtr)
        {
            return Math.Max(MinCloseBeyondPips, factorAtr * atrPips);
        }
        private static bool IsFiniteDouble(double x) => !(double.IsNaN(x) || double.IsInfinity(x));

        private int _maxMetricsCache = 0, _maxBoxCache = 0, _maxExpectedLabels = 0;

        private const int MAX_METRICS_CACHE = 2000;   // hard cap
        private const int MAX_BOX_CACHE     = 1500;   // hard cap
        private const int MAX_EXPECTED      = 200;    // hard cap

        private const string STRATEGY_VERSION = "TEMA_Scalper 2025-10-04 (r1)"; // pon commit/semver aquí
        private string _runId;
        private string _paramHash;
        // --- Reproducibilidad / meta extendida ---
        private string _codeHash;        // fingerprint del binario (Assembly+MVID)
        private string _paramsKVJson;    // snapshot de parámetros (JSON)
        private string _barsDigest;      // hash rápido del dataset de barras
        private int    _barsCount;       // número de barras en M5 usado al inicio
        private string _runMode;         // Backtest / Optimization / Live
        
        // Historial de spread (pips) para detectar spikes vs mediana
        private readonly Queue<double> _spreadPipsHist = new Queue<double>(Policy.SPREAD_MED_WINDOW_BARS);

        private static string Sha256(string s)
        {
            using (var sha = SHA256.Create())
            {
                var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(s ?? ""));
                var sb = new StringBuilder(bytes.Length * 2);
                foreach (var b in bytes) sb.Append(b.ToString("x2"));
                return sb.ToString();
            }
        }

        private string ComputeCodeHash()
        {
            try
            {
                var asm  = typeof(TEMA_Scalper_Levels_MomentumSnap).Assembly;
                var name = asm.GetName();
                var mvid = asm.ManifestModule?.ModuleVersionId ?? Guid.Empty;
                return $"{name.Name}@{name.Version}+MVID={mvid:D}";
            }
            catch { return "unknown"; }
        }
        // --- Detección de modo de ejecución sin depender de IsOptimization ---
        private string GetRunMode()
        {
            try
            {
                // Preferencia: si existe IsBacktesting → Backtest
                var propBT = GetType().GetProperty("IsBacktesting");
                if (propBT != null && propBT.PropertyType == typeof(bool))
                {
                    bool isBT = (bool)propBT.GetValue(this);
                    if (isBT) return "Backtest";
                }

                // Si existe IsOptimization en tu versión, úsalo (vía reflection para no romper compatibilidad)
                var propOPT = GetType().GetProperty("IsOptimization");
                if (propOPT != null && propOPT.PropertyType == typeof(bool))
                {
                    bool isOpt = (bool)propOPT.GetValue(this);
                    if (isOpt) return "Optimization";
                }
            }
            catch { /* no-op */ }

            // Fallback: directo a Live/Forward
            return "Live";
        }
        // --- JSON compacto de todos los [Parameter] (nombre=valor real) ---
        private string BuildParamsKVJson()
        {
            var inv = CultureInfo.InvariantCulture;
            string esc(string x) => (x ?? "").Replace("\\", "\\\\").Replace("\"", "\\\"");
            string kv(string k, string v) => $"\"{esc(k)}\":{v}";

            var props = GetType().GetProperties();
            var items = new List<string>();

            foreach (var p in props)
            {
                var hasParam = p.CustomAttributes.Any(a => a.AttributeType.Name == "ParameterAttribute");
                if (!hasParam) continue;

                object v = null;
                try { v = p.GetValue(this, null); } catch { }

                string jsonVal;
                switch (v)
                {
                    case null:         jsonVal = "null"; break;
                    case bool b:       jsonVal = b ? "true" : "false"; break;
                    case string s:     jsonVal = $"\"{esc(s)}\""; break;
                    case Enum e:       jsonVal = $"\"{esc(e.ToString())}\""; break;
                    case IFormattable f: jsonVal = f.ToString(null, inv).Replace(",", "."); break;
                    default:           jsonVal = $"\"{esc(v.ToString())}\""; break;
                }
                items.Add(kv(p.Name, jsonVal));
            }
            return "{" + string.Join(",", items) + "}";
        }

        private string BuildParamsSnapshotJson()
        {
            var props = GetType().GetProperties()
                .Where(p => p.CustomAttributes.Any(a => a.AttributeType.Name == "ParameterAttribute"))
                .OrderBy(p => p.Name, StringComparer.Ordinal);

            var inv = CultureInfo.InvariantCulture;
            var sb = new StringBuilder("{");
            bool first = true;
            foreach (var p in props)
            {
                var v = p.GetValue(this, null);
                var s = Convert.ToString(v, inv) ?? "";
                string esc(string x) => x.Replace("\\", "\\\\").Replace("\"", "\\\"");
                if (!first) sb.Append(',');
                first = false;
                sb.Append('\"').Append(p.Name).Append("\":\"").Append(esc(s)).Append('\"');
            }
            sb.Append('}');
            return sb.ToString();
        }
        private (int count, string digest) ComputeBarsDigest(Bars b)
        {
            int n = b?.Count ?? 0;
            if (n <= 0) return (0, "");

            var inv = CultureInfo.InvariantCulture;
            var sb = new StringBuilder();

            void addRec(int i)
            {
                sb.Append(b.OpenTimes[i].ToString("o"));
                sb.Append('|').Append(b.OpenPrices[i].ToString(inv));
                sb.Append('|').Append(b.HighPrices[i].ToString(inv));
                sb.Append('|').Append(b.LowPrices[i].ToString(inv));
                sb.Append('|').Append(b.ClosePrices[i].ToString(inv));
                sb.Append(';');
            }

            int take = Math.Min(5, n);
            for (int i = 0; i < take; i++) addRec(i);
            for (int i = Math.Max(take, n - take); i < n; i++) addRec(i);

            return (n, Sha256(sb.ToString()));
        }
        private string BuildBarsDigest()
        {
            try
            {
                if (Bars == null || Bars.Count == 0) return "";
                int n = Bars.Count;
                var inv = CultureInfo.InvariantCulture;

                string key = string.Join("|", new[]
                {
                    SymbolName,
                    Bars.TimeFrame.ToString(),
                    n.ToString(inv),
                    Bars.OpenTimes[0].ToString("o"),
                    Bars.OpenTimes[n-1].ToString("o"),
                    Bars.OpenPrices[0].ToString("R", inv),
                    Bars.HighPrices[0].ToString("R", inv),
                    Bars.LowPrices[0].ToString("R", inv),
                    Bars.ClosePrices[0].ToString("R", inv),
                    Bars.OpenPrices[n-1].ToString("R", inv),
                    Bars.HighPrices[n-1].ToString("R", inv),
                    Bars.LowPrices[n-1].ToString("R", inv),
                    Bars.ClosePrices[n-1].ToString("R", inv),
                });

                return Sha256(key);
            }
            catch { return ""; }
        }
        // Toma todos los [Parameter] via reflexión, los ordena y hashea nombre=valor
        private string ComputeParamHashDeterministic()
        {
            var dict = new SortedDictionary<string,string>(StringComparer.Ordinal);
            var props = GetType().GetProperties();
            foreach (var p in props)
            {
                var hasParam = p.CustomAttributes.Any(a => a.AttributeType.Name == "ParameterAttribute");
                if (!hasParam) continue;
                var v = p.GetValue(this, null);
                var s = Convert.ToString(v, CultureInfo.InvariantCulture) ?? "";
                dict[p.Name] = s;
            }
            var joined = string.Join("|", dict.Select(kv => $"{kv.Key}={kv.Value}"));
            return Sha256(joined);
        }

        // Serializa un JSON compacto sin dependencias externas
        private string BuildMetaJson()
        {
            var tf = Bars?.TimeFrame.ToString() ?? "";
            var from = (Bars?.Count ?? 0) > 0 ? Bars.OpenTimes[0].ToString("o") : "";
            var to   = (Bars?.Count ?? 0) > 0 ? Bars.OpenTimes[Bars.Count - 1].ToString("o") : "";
            // valores directos para evitar depender del orden de OnStart
            double pipSize = Symbol?.PipSize ?? 0.0;
            double lotSize = Symbol?.LotSize ?? 0.0;
            int    digits  = Symbol?.Digits ?? 0;

            var inv = CultureInfo.InvariantCulture;
            string esc(string x) => (x ?? "").Replace("\\", "\\\\").Replace("\"", "\\\"");
            // NOTA: params_kv se inserta como objeto JSON (sin comillas)
            return "{"
                + $"\"run_id\":\"{esc(_runId)}\","
                + $"\"strategy_version\":\"{esc(STRATEGY_VERSION)}\","
                + $"\"code_hash\":\"{esc(_codeHash)}\","
                + $"\"param_hash\":\"{esc(_paramHash)}\","
                + $"\"params_kv\":{(_paramsKVJson ?? "{}")},"
                + $"\"symbol\":\"{esc(SymbolName)}\","
                + $"\"timeframe\":\"{esc(tf)}\","
                + $"\"data_span\":\"{esc(from)}..{esc(to)}\","
                + $"\"bars_count\":{_barsCount.ToString(inv)},"
                + $"\"bars_digest\":\"{esc(_barsDigest)}\","
                + $"\"run_mode\":\"{esc(_runMode)}\","
                + $"\"spread_model\":\"{esc(Meta_SpreadModel)}\","
                + $"\"commission_model\":\"{esc(Meta_CommissionModel)}\","
                + $"\"slippage_model\":\"{esc(Meta_SlippageModel)}\","
                + $"\"entry_mode\":\"{esc(EntryMode)}\","
                + $"\"tp_mode\":\"{esc(TP_Mode)}\","
                + $"\"account_currency\":\"{esc(Account?.Currency)}\","
                + $"\"account_leverage\":\"{Account?.Leverage.ToString(inv)}\","
                + $"\"pip_size\":{pipSize.ToString(inv)},"
                + $"\"lot_size\":{lotSize.ToString(inv)},"
                + $"\"symbol_digits\":{digits},"
                + $"\"clr_version\":\"{esc(Environment.Version.ToString())}\","
                + $"\"clock_info\":\"TZ=UTC;DST=none\""
                + "}";
        }


        private void LogMeta(string phase)  // phase: START / END
        {
            var json = BuildMetaJson();
            Print($"[META.{phase}] {json}");
        }
        // =========================
        //  TRADES: tracking por leg
        // =========================
        private sealed class TradeLegTrack
        {
            public long PosId;
            public string TradeId;
            public string ParentSignalId;
            public string FromOrderRef;   // "market_direct" | "stop_from_label:<label>"
            public string Label;
            public string Trig;           // BOS/ENG/PIN/FBK/MOM/NA
            public DateTime OpenTime;
            public int OpenBarIndex;
            public double Entry;
            public double ExpectedEntry;
            public double SlippagePips;
            public double SizeUnits;
            public double RiskPctUsed;
            public double SlPipsAtEntry;
            public double TpPipsAtEntry;

            // Contexto al fill
            public double AtrAtFill;
            public double SpreadAtFillPips;
            public double Ema20SlopeAtFillPips;
            public string SessionId; // S1/S2/OFF
            public int DoW;
            public int HourBin;

            // Gestión/seguimiento durante vida
            public DateTime? BeTime;
            public DateTime? FirstTrailTime;
            public int NTrailSteps;
            public double MaePips; // >0 = máxima adversa
            public double MfePips; // >0 = máxima favorable
        }
        // ========= Daily aggregates (AGREGADOS DIARIOS) =========
        private DailyAgg _daily;              // estado del día en curso
        private DailyCsvLogger _dailyLogger;  // escritor de daily.csv
        // Formato invariante que usan los loggers
        private readonly CultureInfo _invariant = CultureInfo.InvariantCulture;
        // CSV simple para trades
        private sealed class TradesCsvLogger
        {
            private readonly Action<string> _print;
            private readonly string _path;
            private System.IO.StreamWriter _w;
            private bool _headerWritten;

            public TradesCsvLogger(string runDir, string runId, Action<string> print)
            {
                _print = print;
                try
                {
                    System.IO.Directory.CreateDirectory(runDir);
                    _path = System.IO.Path.Combine(runDir, $"trades_{runId}.csv");
                    _w = new System.IO.StreamWriter(_path, false, Encoding.UTF8);
                    WriteHeader();
                    _print?.Invoke($"[trades.csv] → {_path}");
                }
                catch (Exception ex)
                {
                    _print?.Invoke($"[ERR][trades.csv open] {ex.Message} — imprimiré filas por consola.");
                    _w = null; _headerWritten = false;
                }
            }

            private static string Q(string s) =>
                "\"" + (s ?? "").Replace("\"", "\"\"") + "\"";

            private void WriteHeader()
            {
                if (_headerWritten) return;
                string hdr =
        "trade_id,parent_signal_id,from_order_ref,label,trig," +
        "time_filled,entry_price,expected_entry,slippage_pips,size_units,risk_pct_used,sl_pips_at_entry,tp_pips_at_entry," +
        "be_time,first_trail_time,n_trail_steps," +
        "exit_time,exit_price,exit_reason," +
        "pnl_pips,pnl_r,duration_bars,MAE_pips,MFE_pips," +
        "atr_at_fill,spread_at_fill_pips,ema20_slope_at_fill_pips,session_id,dow,hour_bin";
                if (_w != null) { _w.WriteLine(hdr); _w.Flush(); }
                else _print?.Invoke("[trades.csv header] " + hdr);
                _headerWritten = true;
            }

            public void Append(
                string trade_id, string parent_signal_id, string from_order_ref, string label, string trig,
                DateTime time_filled, double entry_price, double expected_entry, double slippage_pips,
                double size_units, double risk_pct_used, double sl_pips_at_entry, double tp_pips_at_entry,
                DateTime? be_time, DateTime? first_trail_time, int n_trail_steps,
                DateTime exit_time, double exit_price, string exit_reason,
                double pnl_pips, double pnl_r, int duration_bars, double mae_pips, double mfe_pips,
                double atr_at_fill, double spread_at_fill_pips, double ema20_slope_at_fill_pips,
                string session_id, int dow, int hour_bin)
            {
                string dt(DateTime? t) => t.HasValue ? t.Value.ToString("o") : "";
                string line =
                    $"{Q(trade_id)},{Q(parent_signal_id)},{Q(from_order_ref)},{Q(label)},{Q(trig)}," +
                    $"{Q(time_filled.ToString("o"))},{entry_price.ToString(CultureInfo.InvariantCulture)},{expected_entry.ToString(CultureInfo.InvariantCulture)},{slippage_pips.ToString(CultureInfo.InvariantCulture)}," +
                    $"{size_units.ToString(CultureInfo.InvariantCulture)},{risk_pct_used.ToString(CultureInfo.InvariantCulture)},{sl_pips_at_entry.ToString(CultureInfo.InvariantCulture)},{tp_pips_at_entry.ToString(CultureInfo.InvariantCulture)}," +
                    $"{Q(dt(be_time))},{Q(dt(first_trail_time))},{n_trail_steps}," +
                    $"{Q(exit_time.ToString("o"))},{exit_price.ToString(CultureInfo.InvariantCulture)},{Q(exit_reason)}," +
                    $"{pnl_pips.ToString(CultureInfo.InvariantCulture)},{pnl_r.ToString(CultureInfo.InvariantCulture)},{duration_bars},{mae_pips.ToString(CultureInfo.InvariantCulture)},{mfe_pips.ToString(CultureInfo.InvariantCulture)}," +
                    $"{atr_at_fill.ToString(CultureInfo.InvariantCulture)},{spread_at_fill_pips.ToString(CultureInfo.InvariantCulture)},{ema20_slope_at_fill_pips.ToString(CultureInfo.InvariantCulture)}," +
                    $"{Q(session_id)},{dow},{hour_bin}";
                if (_w != null) { _w.WriteLine(line); _w.Flush(); }
                else _print?.Invoke("[trades.csv] " + line);
            }

            public void Close()
            {
                try { _w?.Flush(); _w?.Dispose(); } catch { /* no-op */ }
            }
        }

       private string CurrentSessionId(DateTime t)
        {
            bool s1 = InSession(t, Session1Start, Session1End);
            bool s2 = InSession(t, Session2Start, Session2End);
            if (s1 && !s2) return "S1";
            if (!s1 && s2) return "S2";
            if (s1 && s2)  return "S12"; // solapado (raro, pero contemplado)
            return "OFF";
        }


        private string ParentSignalIdFallback()
        {
            int i = Bars != null && Bars.Count > 0 ? Bars.Count - 1 : -1;
            return $"{_runId}:{i}:{SymbolName}";
        }

        // =====================================================
        // TelemetryFunnel
        // =====================================================
        private sealed class TelemetryFunnel
        {
            public enum CancelReason
            {
                TrendMisalign,
                FBKMacroInvalid,
                MicroBoxTooWide,
                TwoOppClosesBeyond,
                RegimeChange,
                Timeout,
                SessionEnd,
                SlippageAdverse,
                Manual,
                BotStop
            }

            public enum CloseReason { SessionEnd, BotStop }
            private static readonly string[] TRIGS = new[] { "BOS", "ENG", "PIN", "FBK", "MOM" };
            private readonly TEMA_Scalper_Levels_MomentumSnap bot;
            private sealed class Bag
            {
                // Barras
                public long bars_seen, bars_noise_ok, bars_regime_ok;
                // Señales
                public readonly Dictionary<string,long> signals_candidates =
                    TRIGS.ToDictionary(t => t, _ => 0L, StringComparer.OrdinalIgnoreCase);
                public readonly Dictionary<string,long> signals_valid_zone =
                    TRIGS.ToDictionary(t => t, _ => 0L, StringComparer.OrdinalIgnoreCase);
                // Reentrada bloqueada
                public long reentry_blocked_long, reentry_blocked_short;
                // Órdenes
                public long orders_placed_long, orders_placed_short;
                public readonly Dictionary<CancelReason,long> orders_canceled_enum = new();
                public readonly Dictionary<string,long>      orders_canceled_str  = new(StringComparer.OrdinalIgnoreCase);
                public long orders_expired;
                // Fills
                public long fills_market_long, fills_market_short, fills_stop_long, fills_stop_short;
                // Gestión / salidas
                public long tp1_hits, tp2_hits, sl_hits, be_moves, trail_moves, force_close;

                public void AddTo(Bag dst)
                {
                    dst.bars_seen      += bars_seen;
                    dst.bars_noise_ok  += bars_noise_ok;
                    dst.bars_regime_ok += bars_regime_ok;

                    foreach (var kv in signals_candidates) dst.signals_candidates[kv.Key] += kv.Value;
                    foreach (var kv in signals_valid_zone) dst.signals_valid_zone[kv.Key] += kv.Value;

                    dst.reentry_blocked_long  += reentry_blocked_long;
                    dst.reentry_blocked_short += reentry_blocked_short;

                    dst.orders_placed_long  += orders_placed_long;
                    dst.orders_placed_short += orders_placed_short;

                    foreach (var kv in orders_canceled_enum)
                        dst.orders_canceled_enum[kv.Key] = dst.orders_canceled_enum.TryGetValue(kv.Key, out var v) ? v + kv.Value : kv.Value;
                    foreach (var kv in orders_canceled_str)
                        dst.orders_canceled_str[kv.Key]  = dst.orders_canceled_str.TryGetValue(kv.Key, out var v) ? v + kv.Value : kv.Value;

                    dst.orders_expired += orders_expired;

                    dst.fills_market_long += fills_market_long;
                    dst.fills_market_short += fills_market_short;
                    dst.fills_stop_long += fills_stop_long;
                    dst.fills_stop_short += fills_stop_short;

                    dst.tp1_hits += tp1_hits;
                    dst.tp2_hits += tp2_hits;
                    dst.sl_hits  += sl_hits;
                    dst.be_moves += be_moves;
                    dst.trail_moves += trail_moves;
                    dst.force_close += force_close;
                }
            }

            private Bag _day = new Bag();
            private readonly Bag _tot = new Bag();

            public TelemetryFunnel(TEMA_Scalper_Levels_MomentumSnap bot) { this.bot = bot; }

            // ---------- Barras ----------
            public void IncBarsSeen()      => _day.bars_seen++;
            public void IncBarsNoiseOk()   => _day.bars_noise_ok++;
            public void IncBarsRegimeOk()  => _day.bars_regime_ok++;
            // aliases
            public void OnBarSeen()  => IncBarsSeen();
            public void OnNoiseOk()  => IncBarsNoiseOk();
            public void OnRegimeOk() => IncBarsRegimeOk();
            // ---------- Señales ----------
            public void IncSignalCandidate(string trig)
            {
                trig = (trig ?? "NA").ToUpperInvariant();
                if (_day.signals_candidates.ContainsKey(trig)) _day.signals_candidates[trig]++;
            }
            public void IncSignalValidZone(string trig)
            {
                trig = (trig ?? "NA").ToUpperInvariant();
                if (_day.signals_valid_zone.ContainsKey(trig)) _day.signals_valid_zone[trig]++;
            }
            // aliases
            public void OnSignalCandidate(string t) => IncSignalCandidate(t);
            public void OnSignalValidZone(string t) => IncSignalValidZone(t);
            // ---------- Bloqueos ----------
            public void IncReentryBlocked(bool wasLong)
            { if (wasLong) _day.reentry_blocked_long++; else _day.reentry_blocked_short++; }
            // llamadas tipo IncReentryBlocked("MOM", up)
            public void IncReentryBlocked(string trig, bool wasLong) => IncReentryBlocked(wasLong);
            public void IncReentryBlocked(bool wasLong, string reason) => IncReentryBlocked(wasLong);
            // ---------- Órdenes ----------
            public void IncOrderPlaced(bool longSide)
            { if (longSide) _day.orders_placed_long++; else _day.orders_placed_short++; }
            // llamadas tipo OnOrderPlaced("MOM", true, "Stop")
            public void OnOrderPlaced(string trig, bool wasLong, string mode) => IncOrderPlaced(wasLong);
            public void OnOrderPlaced(string side, string trig, string mode)
            {
                side = (side ?? "").ToUpperInvariant();
                IncOrderPlaced(side == "BUY");
            }

            public void IncOrderCanceled(CancelReason r)
            {
                _day.orders_canceled_enum[r] = _day.orders_canceled_enum.TryGetValue(r, out var v) ? v + 1 : 1;
            }
            public void OnOrderCanceled(string trig, bool wasLong, string reason)
            {
                var key = (reason ?? "UNKNOWN").ToUpperInvariant();
                _day.orders_canceled_str[key] = _day.orders_canceled_str.TryGetValue(key, out var v) ? v + 1 : 1;
            }
            public void OnOrderCanceled(string reason)
            {
                var key = (reason ?? "UNKNOWN").ToUpperInvariant();
                _day.orders_canceled_str[key] = _day.orders_canceled_str.TryGetValue(key, out var v) ? v + 1 : 1;
            }

            public void IncOrderExpired() => _day.orders_expired++;
            // ---------- Fills ----------
            public void OnFill(string channel) // "MKT"|"STP"
            {
                channel = (channel ?? "").ToUpperInvariant();
                bool isMarket = channel == "MKT";
                // sin lado aquí, sumamos al total genérico
                if (isMarket) _day.fills_market_long++; else _day.fills_stop_long++;
            }
            // llamada extendida desde OnPositionOpened(...)
            public void OnFill(string trig, bool wasLong, string fillKind, double volumeUnits,
                               double entryPrice, double? stopLoss, double? takeProfit, double slipPips)
            {
                bool isMarket = !string.IsNullOrEmpty(fillKind) && fillKind.StartsWith("M", StringComparison.OrdinalIgnoreCase);
                if (isMarket)
                    if (wasLong) _day.fills_market_long++; else _day.fills_market_short++;
                else
                    if (wasLong) _day.fills_stop_long++; else _day.fills_stop_short++;
            }
            // ---------- Gestión / salidas ----------
            public void IncTP1()   => _day.tp1_hits++;
            public void IncTP2()   => _day.tp2_hits++;
            public void IncSL()    => _day.sl_hits++;
            public void IncBE()    => _day.be_moves++;
            public void IncTrail() => _day.trail_moves++;
            public void IncForceClose() => _day.force_close++;
            // llamada extendida desde OnPositionsClosed(...)
            // outcome: "TP1"|"TP2"|"SL"|"BE"|"TRAIL_MOVE"|"FORCE"|...
            public void OnClose(string trig, bool wasLong, string outcome,
                                double volumeUnits, double entryPrice, double exitPrice,
                                double gross, double net, double pips, TimeSpan duration)
            {
                switch ((outcome ?? "").ToUpperInvariant())
                {
                    case "TP1": IncTP1(); break;
                    case "TP2": IncTP2(); break;
                    case "SL":  IncSL();  break;
                    case "BE":
                    case "BE_MOVE": IncBE(); break;
                    case "TRAIL_MOVE": IncTrail(); break;
                    case "FORCE": IncForceClose(); break;
                    default: break;
                }
            }
            // ---------- Reportes ----------
            private static double Rate(long a, long b) => b > 0 ? 100.0 * a / b : 0.0;

            private void PrintSummary(string prefix)
            {
                long bars_seen      = _day.bars_seen;
                long bars_noise_ok  = _day.bars_noise_ok;
                long bars_regime_ok = _day.bars_regime_ok;

                double r_noise  = Rate(bars_noise_ok, bars_seen);
                double r_regime = Rate(bars_regime_ok, Math.Max(1, bars_noise_ok));

                long cand  = _day.signals_candidates.Values.Sum();
                long valid = _day.signals_valid_zone.Values.Sum();

                double r_valid = Rate(valid, Math.Max(1, cand));

                long orders = _day.orders_placed_long + _day.orders_placed_short;
                long fills  = _day.fills_market_long + _day.fills_market_short + _day.fills_stop_long + _day.fills_stop_short;
                double r_fill = Rate(fills, Math.Max(1, orders));

                bot.Print($"[Funnel/{prefix}] bars={bars_seen} noise_ok={bars_noise_ok}({r_noise:F1}%) regime_ok={bars_regime_ok}({r_regime:F1}%) | cand={cand} valid={valid}({r_valid:F1}%) | orders={orders} fills={fills}({r_fill:F1}%)");
            }
       
            public void FlushDay(string prefix)
            {
                PrintSummary(prefix);
                _day.AddTo(_tot);
                _day = new Bag(); // reset del día
            }

            public void FlushFinal()
            {
                var snap = new Bag();
                _tot.AddTo(snap);
                // imprime total como "Total"
                var oldDay = _day; _day = snap;
                PrintSummary("Total");
                _day = oldDay;
            }

            public void PrintSnapshot(string prefix = "Funnel")
            {
                long cancelsEnum = _day.orders_canceled_enum.Values.Sum();
                long cancelsStr  = _day.orders_canceled_str.Values.Sum();
                long cancelsTotal = Math.Max(cancelsEnum, cancelsStr);
                bot.Print($"[{prefix}] seen={_day.bars_seen} noise_ok={_day.bars_noise_ok} regime_ok={_day.bars_regime_ok} | " +
                          $"orders(B/S)={_day.orders_placed_long}/{_day.orders_placed_short} cancels={_day.orders_canceled_enum.Values.Sum()+_day.orders_canceled_str.Values.Sum()} exp={_day.orders_expired} | " +
                          $"fills MKT(L/S)={_day.fills_market_long}/{_day.fills_market_short} STP(L/S)={_day.fills_stop_long}/{_day.fills_stop_short} | " +
                          $"TP1={_day.tp1_hits} TP2={_day.tp2_hits} SL={_day.sl_hits} BE={_day.be_moves} TR={_day.trail_moves} FORCE={_day.force_close}");
            }
        }
        // ─────────────────────────────────────────────────────────────
        // OrdersCsvLogger: una sola fila por orden (al resolverse)
        // ─────────────────────────────────────────────────────────────
        private sealed class OrdersCsvLogger : IDisposable
        {
            public sealed class Row
            {
                public string run_id, order_id, signal_id, time_placed, type, label, dir;
                public string entry_price, sl_pips, tp_pips, entry_buffer_pips;
                public string time_expire, time_filled, time_canceled, cancel_reason;
                public string best_reach_price_before_cancel, min_distance_to_entry_pips;
                public string trend_ok_at_place, box_state_at_place;
            }

            private readonly string _path;
            private readonly Action<string> _print;
            private readonly List<Row> _buffer = new();       // filas listas para volcar
            private readonly Dictionary<string, Row> _open = new(); // por order_id (pendientes en memoria)
            private readonly object _lock = new();

          
            public OrdersCsvLogger(string baseDir, string runId, Action<string> print)
            {
                _print = print ?? Console.WriteLine;
                System.IO.Directory.CreateDirectory(baseDir);
                _path = System.IO.Path.Combine(baseDir, "orders.csv");

                if (!System.IO.File.Exists(_path))
                {
                    System.IO.File.WriteAllText(_path,
                        "run_id,order_id,signal_id,time_placed,type,label,dir,entry_price,sl_pips,tp_pips,entry_buffer_pips,time_expire,time_filled,time_canceled,cancel_reason,best_reach_price_before_cancel,min_distance_to_entry_pips,trend_ok_at_place,box_state_at_place\n");
                }
            }
           
            private static string Esc(string s) => (s ?? "").Replace("\"","\"\"");
            private static string Csv(params string[] cols)
                => string.Join(",", cols.Select(c => $"\"{Esc(c)}\""));

            public void OnPlaced(string runId, string orderId, string signalId,
                                 DateTime timePlaced, string type, string label, string dir,
                                 double entryPrice, double slPips, double tpPips, double entryBufPips,
                                 DateTime? expire, bool trendOk, string boxState)
            {
                lock (_lock)
                {
                    var r = new Row
                    {
                        run_id = runId,
                        order_id = orderId,
                        signal_id = signalId ?? "",
                        time_placed = timePlaced.ToString("o"),
                        type = type,
                        label = label ?? "",
                        dir = dir,
                        entry_price = entryPrice.ToString(CultureInfo.InvariantCulture),
                        sl_pips = slPips.ToString(CultureInfo.InvariantCulture),
                        tp_pips = tpPips.ToString(CultureInfo.InvariantCulture),
                        entry_buffer_pips = entryBufPips.ToString(CultureInfo.InvariantCulture),
                        time_expire = expire.HasValue ? expire.Value.ToString("o") : "",
                        time_filled = "",
                        time_canceled = "",
                        cancel_reason = "",
                        best_reach_price_before_cancel = "",
                        min_distance_to_entry_pips = "",
                        trend_ok_at_place = trendOk ? "true" : "false",
                        box_state_at_place = boxState ?? ""
                    };
                    _open[orderId] = r;
                }
            }

            public void OnFilled(string orderId, DateTime timeFilled)
            {
                lock (_lock)
                {
                    if (_open.TryGetValue(orderId, out var r))
                    {
                        r.time_filled = timeFilled.ToString("o");
                        FlushRow(r);
                        _open.Remove(orderId);
                    }
                }
            }

            public void OnCanceled(string orderId, DateTime timeCanceled, string reason,
                                   double? bestReachPrice, double? minDistPips)
            {
                lock (_lock)
                {
                    if (_open.TryGetValue(orderId, out var r))
                    {
                        r.time_canceled = timeCanceled.ToString("o");
                        r.cancel_reason = reason ?? "UNKNOWN";
                        if (bestReachPrice.HasValue)
                            r.best_reach_price_before_cancel = bestReachPrice.Value.ToString(CultureInfo.InvariantCulture);
                        if (minDistPips.HasValue && IsFiniteDouble(minDistPips.Value))
                            r.min_distance_to_entry_pips = minDistPips.Value.ToString(CultureInfo.InvariantCulture);

                        FlushRow(r);
                        _open.Remove(orderId);
                    }
                }
            }

            public void OnExpired(string orderId, DateTime timeExpired)
            {
                OnCanceled(orderId, timeExpired, "EXPIRED_TIMEOUT", null, null);
            }

            private void FlushRow(Row r)
            {
                var line = Csv(
                    r.run_id, r.order_id, r.signal_id, r.time_placed, r.type, r.label, r.dir,
                    r.entry_price, r.sl_pips, r.tp_pips, r.entry_buffer_pips,
                    r.time_expire, r.time_filled, r.time_canceled, r.cancel_reason,
                    r.best_reach_price_before_cancel, r.min_distance_to_entry_pips,
                    r.trend_ok_at_place, r.box_state_at_place
                );
                System.IO.File.AppendAllText(_path, line + "\n");
            }

            public void Dispose() { /* no-op */ }
        }
        // =========================
        //         START
        // =========================
       protected override void OnStart()
        {
            // ==== 0) Identidad y hashes (reproducibilidad) ====
            _runId     = Guid.NewGuid().ToString();
            _paramHash = ComputeParamHashDeterministic();
            // === signals.csv ===
            try
            {
                string signalsDir = System.IO.Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
                    "cAlgo", "TEMA_Scalper", "telemetry");
                System.IO.Directory.CreateDirectory(signalsDir);

                var fname = $"signals_{SymbolName}_{Bars?.TimeFrame}_{_runId}.csv";
                var fpath = System.IO.Path.Combine(signalsDir, fname);

                _signalsWriter = new System.IO.StreamWriter(fpath, false, Encoding.UTF8);
                WriteSignalsHeaderIfNeeded();
                Print($"[signals.csv] → {fpath}");
            }
            catch (Exception ex)
            {
                Print($"[ERR][signals.csv open] {ex.Message} — imprimiré las filas por consola.");
                _signalsWriter = null; _signalsHeaderWritten = false;
            }
            // Telemetría (funnel) — SOLO una vez
            _tm = new TelemetryFunnel(this);
            // === Carpeta base del RUN ===
            string runDir = System.IO.Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
                "TEMA_Scalper",
                _runId);
            try { System.IO.Directory.CreateDirectory(runDir); } catch { /* ok */ }
            // Loggers de runtime
            _orders = new OrdersCsvLogger(runDir, _runId, Print);
            _trades = new TradesCsvLogger(runDir, _runId, Print);
            _dailyLogger = new DailyCsvLogger(runDir, _runId, Print);
            // Hashes/meta
            _codeHash  = Sha256(STRATEGY_VERSION);
            _runMode   = GetRunMode();
            _paramsKVJson = BuildParamsKVJson();

            var bc = ComputeBarsDigest(Bars);
            _barsCount  = bc.count;
            _barsDigest = bc.digest;
            // META START
            LogMeta("START");
            // Perfil
            ApplyProfile(Profile, TriggerAgg, StructureStrict, ExecStrict, RiskProfile);
            // Conversores de símbolo
            _pipSize        = Symbol.PipSize;
            _pipToPrice     = _pipSize;
            _priceToPipsFactor = (_pipSize > 0.0) ? (1.0 / _pipSize) : 0.0;
            _unitsPerLot    = Symbol.LotSize;
            // Ventanas/lookbacks
            _reentryWin = Math.Max(3, ReentryBoxLB);
            _microWin   = Math.Max(3, MicroBoxLB);

            _mxReentryHigh = new MonoMax(idx => _barsM5.HighPrices[idx], _reentryWin);
            _mnReentryLow  = new MonoMin(idx => _barsM5.LowPrices[idx],  _reentryWin);
            _mxMicroHigh   = new MonoMax(idx => _barsM5.HighPrices[idx], _microWin);
            _mnMicroLow    = new MonoMin(idx => _barsM5.LowPrices[idx],  _microWin);
            // Catálogo de triggers
            InitTriggers();
            // Warm-up
            for (int k = 0; k < _barsM5.Count; k++)
            {
                _mxReentryHigh.Push(k);
                _mnReentryLow.Push(k);
                _mxMicroHigh.Push(k);
                _mnMicroLow.Push(k);
            }
            // Indicadores
            _emaFast = Indicators.ExponentialMovingAverage(_barsM5.ClosePrices, EMAfast);
            _emaMed  = Indicators.ExponentialMovingAverage(_barsM5.ClosePrices, EMAmed);
            _emaSlow = Indicators.ExponentialMovingAverage(_barsM5.ClosePrices, EMAslow);
            _atr     = Indicators.AverageTrueRange(14, MovingAverageType.Exponential);

            _barsD1 = MarketData.GetBars(TimeFrame.Daily);
            _barsM1 = MarketData.GetBars(TimeFrame.Minute);
            // Estado de día / niveles + daily agg actual
            _currentDate = Server.Time.Date;
            ResetDayLevels();
            _daily = new DailyAgg(this, _currentDate);      
            // Eventos de posiciones
            Positions.Closed += OnPositionsClosed;
            Positions.Opened += OnPositionOpened;
            _runAgg = new RunAgg(this);
            Print("TEMA Scalper iniciado. Símbolo={0}, TF={1}, RunMode={2}, Bars={3}",
                  SymbolName, Bars.TimeFrame, _runMode, _barsCount);
        }
        // =========================
        //        ON BAR (M5)
        // =========================
        protected override void OnBar()
        {
            try
            {
                CoreOnBar();
            }
            catch (Exception ex)
            {
                Print($"[ERR][OnBar] {ex.Message}");
            }
        }

        protected void CoreOnBar()
        {
            int i = _barsM5.Count - 1;
            UpdateSpreadHistory();
            UpdateLiveMetricsForPendings();
            // 1) Actualiza estructuras O(1) y sanea bloqueo
            if (i >= 0)
            {
                _mxReentryHigh.Push(i);
                _mnReentryLow.Push(i);
                _mxMicroHigh.Push(i);
                _mnMicroLow.Push(i);
            }
            SanityReentryBlock(i);
            // ======= Drenar solicitudes (single-writer) =======
            if (_pendingCooldownUntil > _cooldownUntil)
                _cooldownUntil = _pendingCooldownUntil;

            if (_pendingCancelPendings)
            {
                // TM: pasar motivo de cancelación masiva
                CancelAllPendingsIfAny(_pendingCancelReason);
                _pendingCancelPendings = false;
                _pendingCancelReason = TelemetryFunnel.CancelReason.Manual;
            }

            if (_pendingReentry != 0)
            {
                ArmReentryBlock(_pendingReentry == 1);
                _pendingReentry = 0;
            }

            if (i >= 0) RefreshBarMetrics(i);
            // TM: contar barra vista
            _tm.IncBarsSeen();
            _barsSeen++;
            _barsSinceDayStart++;
            // dentro de CoreOnBar(), al avanzar barras:
            if (i > 0)
            {
                var now  = _barsM5.OpenTimes[i];
                var prev = _barsM5.OpenTimes[i - 1];
                bool inMkt = Positions.Any(p => p.SymbolName == SymbolName);
                _daily?.OnBar(now - prev, inMkt);
            }
          // 1) Cambio de día
            DailyRollIfDateChange();
            // 2) Primero intenta relajar cooldown
            MaybeRelaxCooldown(i);
            // Luego calcula régimen/ruido con el cooldown ya actualizado
            var (okRegime, okNoise) = PrecheckOkSplit();
            _lastNoiseOk  = okNoise;    // ← para signals.csv
            _lastRegimeOk = okRegime;
            // TM: tasas de ruido/régimen
            if (okNoise) _tm.IncBarsNoiseOk();
            if (okNoise && okRegime) _tm.IncBarsRegimeOk();

            if (!okRegime || !okNoise)
            {
                if (CancelPendingsOnRegimeChange && _inRegimePrev && !okRegime)
                    RequestCancelAllPendings(TelemetryFunnel.CancelReason.RegimeChange);
            }
            _inRegimePrev = okRegime;
            // Cancelaciones "soft" por estructura (con motivos internos)
            CancelPendingsIfStructureInvalid();
            // 3) Anti-doble señal en la misma barra
            int barIndex = _barsM5.Count - 1;
            if (barIndex == _lastSignalBarIndex)
            {
                // TM: chequear expiraciones igual
                CheckPendingExpirations();
                return;
            }
            _signalFiredThisBar = false;
            // 4) Señales
            if (EnableMomentumSnap) TryMomentumSnap();
            if (_signalFiredThisBar)
            {
                SafeManageOpenPositions();
                // TM: expiraciones por si algo quedó colgando
                CheckPendingExpirations();
                return;
            }

            TryTemaFlow();
            // 5) Gestión condicional
            if (_signalFiredThisBar)
                SafeManageOpenPositions();
            // ======= Drenar solicitudes (single-writer) =======
            if (_pendingCooldownUntil > _cooldownUntil)
                _cooldownUntil = _pendingCooldownUntil;
            _pendingCooldownUntil = DateTime.MinValue;

            if (_pendingCancelPendings)
            {
                // TM: pasar motivo de cancelación masiva
                CancelAllPendingsIfAny(_pendingCancelReason);
                _pendingCancelPendings = false;
                _pendingCancelReason = TelemetryFunnel.CancelReason.Manual;
            }

            if (_pendingReentry != 0)
            {
                ArmReentryBlock(_pendingReentry == 1);
                _pendingReentry = 0;
            }
            // TM: chequear expiraciones cada barra
            CheckPendingExpirations();
            // Limpieza periódica de caches (cada barra)
            PruneCaches(_barsM5.Count - 1);
        }


        private bool IsNoiseCleanNoCooldown(int i)
        {
            if (i < 0) return false;
            // Spread dentro de umbral con histéresis conservadora
            double spreadPips = PointsToPips(Symbol.Spread);
            if (spreadPips > (SpreadMaxPips + Policy.SPREAD_HYST_MARGIN_PIPS * 0.5)) return false;
            // ATR válido y por encima del mínimo
            double atrPips = SafeAtrPips(i);
            if (atrPips <= 0.0) return false;
            if (atrPips < (ATR_Min_Pips - Policy.ATR_HYST_MARGIN_PIPS * 0.5)) return false;
            // (Opcional) límite superior si lo usas
            if (ATR_Max_Pips > 0.0 && atrPips > ATR_Max_Pips) return false;

            return true;
        }
        // firma correcta
        private void MaybeRelaxCooldown(int i)
        {
            if (!EnableCooldownRelax) { _cooldownCleanStreak = 0; return; }
            if (Server.Time >= _cooldownUntil) { _cooldownCleanStreak = 0; return; }

            bool clean = IsNoiseCleanNoCooldown(i);
            if (clean)
            {
                _cooldownCleanStreak++;
                if (_cooldownCleanStreak >= CooldownRelaxCleanBars)
                {
                    _cooldownUntil = Server.Time;
                    _cooldownCleanStreak = 0;
                    Print($"[CDN] Relax: {CooldownRelaxCleanBars} barras limpias → cooldown off en {Server.Time:HH:mm}");
                }
            }
            else
            {
                _cooldownCleanStreak = 0;
            }
        }


        private void SafeManageOpenPositions()
        {
            if (_inManage) return;           // evita reentradas
            try
            {
                _inManage = true;
                ManageOpenPositions();       // tu lógica actual
            }
            catch (Exception ex)
            {
                Print($"[ERR][ManageOpenPositions] {ex.Message}");
            }
            finally
            {
                _inManage = false;
            }
        }

        private void SanityReentryBlock(int i)
        {
            if (i > _blockUntilBar)
            {
                _blockLong = _blockShort = false;
                _blockHigh = double.NaN;
                _blockLow  = double.NaN;
                _blockStartBar = -1;
            }
        }

        protected override void OnTick()
        {
            try
            {
                UpdateLiveMetricsForPendings();
                SafeManageOpenPositions();
            }
            catch (Exception ex)
            {
                Print($"[ERR][OnTick] {ex.Message}");
            }
        }
        // =========================
        //   RESETEO DE NIVELES
        // =========================
        private void ResetDayLevels()
        {
            if (EnablePrevDayLevels && _barsD1 != null)
            {
                int prevIdx = FindLastClosedD1Index();
                if (prevIdx >= 0)
                {
                    _PDH = _barsD1.HighPrices[prevIdx];
                    _PDL = _barsD1.LowPrices[prevIdx];
                }
                else
                {
                    _PDH = null;
                    _PDL = null;
                }
            }
            else
            {
                _PDH = null;
                _PDL = null;
            }

            
            if (EnableAsiaLevels) ComputeAsiaHL();
            else { _AsiaH = null; _AsiaL = null; }
        }
        // ===============================================
        //   SANITIZADOR DE ATR (anti NaN / cero)
        // ===============================================
        private double SafeAtrPips(int i)
        {
            if (_atr == null || _atr.Result.Count <= i)
                return 0.0;

            double atrPips = PriceToPips(_atr.Result[i]);

            if (double.IsNaN(atrPips) || !IsFiniteDouble(atrPips) || atrPips <= 0.0 || atrPips > Policy.SAFEATR_SANITY_MAX_PIPS)
                return 0.0;

            return atrPips;
        }
        // =========================
        //   ASIA HIGH/LOW (día actual)
        // =========================
        private void ComputeAsiaHL()
        {
            try
            {
                if (_barsM5 == null || _barsM5.Count == 0) { _AsiaH = _AsiaL = null; return; }

                DateTime day = Server.Time.Date;
                var (asiaStart, asiaEnd) = ParseHHmmInterval(AsiaStart, AsiaEnd, day);
                // Dos casos: normal (start < end) o cruce de medianoche (start >= end)
                bool wraps = asiaEnd <= asiaStart;
                double? h = null, l = null;
                // Miramos ~33 horas hacia atrás para cubrir cualquier horario con offset
                int startSearchFrom = Math.Max(0, _barsM5.Count - 400);

                for (int i = _barsM5.Count - 1; i >= startSearchFrom; i--)
                {
                    var t = _barsM5.OpenTimes[i];

                    if (!wraps)
                    {
                        // Ventana del mismo día
                        if (t >= asiaStart && t < asiaEnd)
                        {
                            double hi = _barsM5.HighPrices[i];
                            double lo = _barsM5.LowPrices[i];
                            h = h.HasValue ? Math.Max(h.Value, hi) : hi;
                            l = l.HasValue ? Math.Min(l.Value, lo) : lo;
                        }
                        // Si ya nos fuimos al día anterior, podemos cortar
                        if (t.Date < day) break;
                    }
                    else
                    {
                        // Ventana partida: [asiaStart, day+1) ∪ [day, asiaEnd)
                        bool inLate = (t >= asiaStart && t < day.AddDays(1));
                        bool inEarly = (t >= day && t < asiaEnd);

                        if (inLate || inEarly)
                        {
                            double hi = _barsM5.HighPrices[i];
                            double lo = _barsM5.LowPrices[i];
                            h = h.HasValue ? Math.Max(h.Value, hi) : hi;
                            l = l.HasValue ? Math.Min(l.Value, lo) : lo;
                        }
                        // Cortamos al entrar al día anterior al 'day' base
                        if (t < day.AddDays(-1)) break;
                    }
                }

                _AsiaH = h; _AsiaL = l;
            }
            catch (Exception ex)
            {
                Print("ComputeAsiaHL error: {0}", ex.Message);
                _AsiaH = _AsiaL = null;
            }
        }
        // ===============================================
        //  PRECHECKS: Ruido (spread/ATR/cooldown) + Régimen (sesión + triple EMA)
        // ===============================================
        private (bool okRegime, bool okNoise) PrecheckOkSplit()
        {
            int minBars = Math.Max(EMAslow, 14) + 2;
            if (_barsM5 == null || _barsM5.Count < minBars)
                return (false, false);

            bool okNoise = true;
            // --- Cooldown temporal (por racha o slippage)
            if (Server.Time < _cooldownUntil)
                okNoise = false;
            // === Gracia al arrancar el día (afecta a spread y ATR)
            if (_barsSinceDayStart <= DayStartGraceBars)
            {
                _spreadOkPrev = true;
                _atrOkPrev = true;
            }
            // --- SPREAD con histéresis + cap dinámico vs ATR + spike vs mediana
            UpdateSpreadHistory(); // idempotente; ok si ya lo llamas en CoreOnBar()

            double spreadMargin = Policy.SPREAD_HYST_MARGIN_PIPS; // pips
            double spreadPips   = GetCurrentSpreadPips();         // usa tu helper

            int ii = CurrentBarIndex();
            double atrPipsForCap = SafeAtrPips(ii);
            double cap = SpreadMaxPips;
            if (atrPipsForCap > 0.0)
                cap = Math.Min(cap, 0.25 * atrPipsForCap);
            // Spike de spread (mediana 1h): anula el resto
            if (IsSpreadMedianSpike())
            {
                okNoise = false;
                _spreadOkPrev = false;
                _rejSpread++;
            }
            else
            {
                if (_spreadOkPrev)
                {
                    if (spreadPips > cap + spreadMargin)
                    {
                        okNoise = false;
                        _spreadOkPrev = false;
                        _rejSpread++;
                    }
                }
                else
                {
                    if (spreadPips < cap - spreadMargin)
                        _spreadOkPrev = true;
                    else
                        okNoise = false;
                }
            }
            // --- ATR con histéresis + validación segura + anti-spike
            int i = _barsM5.Count - 1;
            double atrPipsNow = SafeAtrPips(i);
            double atrMargin  = Policy.ATR_HYST_MARGIN_PIPS;

            if (atrPipsNow <= 0.0)
            {
                okNoise = false;
                _atrOkPrev = false;
                _rejATR++;
            }
            else
            {
                // Histeresis mínima en el umbral inferior
                if (_atrOkPrev)
                {
                    if (atrPipsNow < ATR_Min_Pips - atrMargin)
                    {
                        okNoise = false;
                        _atrOkPrev = false;
                        _rejATR++;
                    }
                }
                else
                {
                    if (atrPipsNow > ATR_Min_Pips + atrMargin)
                        _atrOkPrev = true;
                    else
                        okNoise = false;
                }
                // Anti-spike: comparar con media reciente
                int lookbackATR = Policy.ATR_SPIKE_LOOKBACK;
                int n = _atr.Result.Count;
                if (n > lookbackATR)
                {
                    double sum = 0.0; int cnt = 0;
                    for (int k = 1; k <= lookbackATR; k++)
                    {
                        double ap = SafeAtrPips(n - k);
                        if (ap > 0.0) { sum += ap; cnt++; }
                    }
                    if (cnt > 0)
                    {
                        double atrAvg = sum / cnt;
                        if (atrAvg > 0.0 && atrPipsNow > atrAvg * Policy.ATR_SPIKE_FACTOR)
                        {
                            okNoise = false;
                            _rejATR++;
                        }
                    }
                }
                // Límite superior opcional (volatilidad excesiva; 0 = OFF)
                if (ATR_Max_Pips > 0.0 && atrPipsNow > ATR_Max_Pips)
                {
                    okNoise = false;
                    _rejATR++;
                }
            }
            // --- Régimen: SESIÓN + TENDENCIA (si procede)
            bool sessionOk = true;
            if (EnableSessionFilter && !IsInAnySession(Server.Time))
                sessionOk = false;

            bool trendOk = true;
            if (UseTrendFilter)
            {
                double emaF = _emaFast.Result[i];
                double emaM = _emaMed.Result[i];
                double emaS = _emaSlow.Result[i];

                bool bull = emaF > emaM && emaM > emaS;
                bool bear = emaF < emaM && emaM < emaS;

                if (!bull && !bear)
                    trendOk = false;

                if (trendOk && !EmaSeparationPasses(i))
                    trendOk = false;

                if (!trendOk)
                    _rejTrend++; // solo contamos si falla de verdad
            }

            bool okRegime = sessionOk && trendOk;
            // --- Contadores diagnósticos
            if (okNoise) _barsPassedNoise++;
            if (okNoise && okRegime) _barsPassedRegime++;

            return (okRegime, okNoise);
        }

        private double GetCurrentSpreadPips()
        {
            // Symbol.Spread está en points; a veces puede venir 0 en backtest/ticks raros.
            double pts = Symbol.Spread;
            if (pts <= 0.0)
                pts = (Symbol.Ask - Symbol.Bid);        
            double pips = PointsToPips(pts);
            if (pips <= 0.0)
                pips = PriceToPips(Symbol.Ask - Symbol.Bid);
            return pips;
        }

        private bool IsInAnySession(DateTime t)
        {
            if (InSession(t, Session1Start, Session1End)) return true;
            if (InSession(t, Session2Start, Session2End)) return true;
            return false;
        }
        private bool IsSpreadMedianSpike()
        {
            int n = _spreadPipsHist.Count;
            // exige un mínimo de muestras para que la mediana sea estable
            if (n < Math.Min(6, Policy.SPREAD_MED_WINDOW_BARS / 2))
                return false;

            var arr = _spreadPipsHist.ToArray();
            Array.Sort(arr);
            double median = (n % 2 == 1) ? arr[n / 2]
                                         : 0.5 * (arr[n / 2 - 1] + arr[n / 2]);

            double now = GetCurrentSpreadPips();
            return now > Policy.SPREAD_SPIKE_MED_MULT * median;
        }
        
        private void UpdateSpreadHistory()
        {
            double s = GetCurrentSpreadPips(); // ya lo tienes; si no: PointsToPips(Symbol.Spread)
            if (s <= 0 || double.IsNaN(s) || double.IsInfinity(s)) return;

            if (_spreadPipsHist.Count == Policy.SPREAD_MED_WINDOW_BARS)
                _spreadPipsHist.Dequeue();
            _spreadPipsHist.Enqueue(s);
        }
        // Actualiza métricas “live” de pendientes para orders.csv
       private void UpdateLiveMetricsForPendings()
        {
            try
            {
                if (PendingOrders == null || PendingOrders.Count == 0) return;

                double mid = (Symbol.Bid + Symbol.Ask) * 0.5;

                // Índice de barra actual para usar High/Low como "mejor alcance"
                int li = (_barsM5 != null ? _barsM5.Count - 1 : -1);
                double hiBar = (li >= 0) ? _barsM5.HighPrices[li] : mid;
                double loBar = (li >= 0) ? _barsM5.LowPrices[li]  : mid;

                for (int i = 0; i < PendingOrders.Count; i++)
                {
                    var po = PendingOrders[i];
                    if (po.SymbolName != SymbolName) continue;
                    if (!_liveById.TryGetValue(po.Id, out var live)) continue;

                    // Precio de referencia “mejor alcanzado” esta barra
                    double refNow = mid;
                    if (live.IsBuy)
                        refNow = Math.Max(refNow, hiBar);   // BUY: mejor es el máximo tocado
                    else
                        refNow = Math.Min(refNow, loBar);   // SELL: mejor es el mínimo tocado

                    // 1) BestReachPrice
                    if (!double.IsNaN(live.BestReachPrice))
                        live.BestReachPrice = live.IsBuy
                            ? Math.Max(live.BestReachPrice, refNow)
                            : Math.Min(live.BestReachPrice, refNow);
                    else
                        live.BestReachPrice = refNow;

                    // 2) MinDistPips vs precio de entrada objetivo (TargetPrice si existe)
                    double entryRef = (po.TargetPrice > 0) ? po.TargetPrice : live.EntryPrice;
                    double distNowPips = PriceToPips(Math.Abs(refNow - entryRef));

                    if (!double.IsNaN(distNowPips) && !double.IsInfinity(distNowPips))
                    {
                        if (double.IsNaN(live.MinDistPips) || double.IsInfinity(live.MinDistPips))
                            live.MinDistPips = distNowPips;
                        else
                            live.MinDistPips = Math.Min(live.MinDistPips, distNowPips);
                    }

                    // 3) (Opcional) reasignación explícita
                    _liveById[po.Id] = live;
                }
            }
            catch (Exception ex)
            {
                Print($"[ERR][UpdateLiveMetricsForPendings] {ex.Message}");
            }
        }




        private bool InSession(DateTime now, string startHHmm, string endHHmm)
        {
            var (start, end) = ParseHHmmInterval(startHHmm, endHHmm, now.Date);

            if (end >= start)
                return now >= start && now < end;
            // Sesión con cruce de medianoche: ej. 22:00 → 02:00 (día siguiente)
            return (now >= start) || (now < end.AddDays(1));
        }

        private (DateTime, DateTime) ParseHHmmInterval(string hhmmStart, string hhmmEnd, DateTime day)
        {
            var s = TimeSpan.Parse(hhmmStart);
            var e = TimeSpan.Parse(hhmmEnd);
            var off = TimeSpan.FromMinutes(SessionOffsetMinutes);
            // devolvemos los DateTime del mismo "day" pero desplazados por el offset
            return (day + s + off, day + e + off);
        }

        private int FindLastClosedD1Index()
        {
            if (_barsD1 == null || _barsD1.Count == 0) return -1;
            // inicio del día actual (zona UTC del robot)
            DateTime dayStart = Server.Time.Date;
            // Recorre hacia atrás hasta hallar una daily cuyo OpenTime < today (=> ya cerrada)
            for (int idx = _barsD1.Count - 1; idx >= 0; idx--)
            {
                if (_barsD1.OpenTimes[idx] < dayStart)
                    return idx;
            }
            return -1;
        }
        // =========================
        //      FLUJO TEMA M5
        // =========================
        private void TryTemaFlow()
        {
            int i = _barsM5.Count - 1;
            if (i < 1) return;

            RefreshBarMetrics(i);
            if (_mAtrPips <= 0) return;
            // 1) Filtro de rango vs ATR (ruido básico)
            double r = _mRangePips / _mAtrPips;
            if (r < MinCandleRangeATR || r > MaxCandleRangeATR) return;

            double price = _mC;
            double emaF = _emaFast.Result[i];
            double emaM = _emaMed.Result[i];
            double emaS = _emaSlow.Result[i];

            bool up = emaF > emaM && emaM > emaS;
            bool dn = emaF < emaM && emaM < emaS;
            if (!up && !dn) return;
            // Spread snapshot para logs (pips)
            double spreadAtSig = (Symbol.Ask - Symbol.Bid) / Symbol.PipSize;
            // 2) Anti-reentrada dentro de la misma caja
            if (IsReentryBlocked(up))
            {
                try { _tm?.IncReentryBlocked(up); } catch { /* no-op */ }
                // No conocemos aún el trigger real → "NA"
                LogSignalCsv(
                    "NA", up, i,
                    zoneOk: false,
                    reentryBlocked: true,
                    triggerCooling: false,
                    action: "skip",
                    skipReason: RejectCode.REENTRY_BLOCKED,
                    dynMinBeyondPips: 0.0,
                    spreadAtSignalPips: spreadAtSig
                );
                return;
            }
            // 3) Entry con buffer dinámico (usado en Stop)
            double entryBuf = _mEntryBufPips;
            double entryPrice = EntryMode.Equals("Market", StringComparison.OrdinalIgnoreCase)
                ? _mC
                : (up ? _barsM5.HighPrices[i] + PipsToPrice(entryBuf)
                      : _barsM5.LowPrices[i]  - PipsToPrice(entryBuf));
            // 4) Micro pullback M1
            if (EnableM1MicroPullback)
            {
                double pbCap  = Math.Min(PB_MaxPips, 0.5 * _mAtrPips);
                double upper  = Math.Max(emaF, emaM) + PipsToPrice(pbCap);
                double lower  = Math.Min(emaF, emaM) - PipsToPrice(pbCap);
                bool pullbackOK = up ? (price <= upper && price >= lower)
                                     : (price >= lower && price <= upper);
                if (!pullbackOK) return;

                if (_barsM1 != null && _barsM1.Count >= M1_MicroBars)
                {
                    int i1 = _barsM1.Count - 1;
                    double maxPB = 0.0;
                    for (int k = 0; k < M1_MicroBars && (i1 - k) >= 0; k++)
                    {
                        double pb = PriceToPips(Math.Abs(_barsM1.ClosePrices[i1 - k] - emaM));
                        if (pb > maxPB) maxPB = pb;
                    }
                    if (maxPB > pbCap) return;
                }
            }
            // 5) Triggers con prioridad declarativa
            string trigTag = PickTrigger(up, i);
            if (trigTag == null) return;
            // 1) ya es candidato (cuenta en el embudo)
            _tm?.IncSignalCandidate(trigTag);
            // 2) reentry block con tag conocido
            if (IsReentryBlocked(up))
            {
                _tm.IncReentryBlocked(trigTag, up);
                LogSignalCsv(
                    trigTag, up, i,
                    zoneOk:false,
                    reentryBlocked:true,
                    triggerCooling:false,
                    action:"skip",
                    skipReason:RejectCode.REENTRY_BLOCKED,
                    dynMinBeyondPips:0.0,
                    spreadAtSignalPips: spreadAtSig
                );
                return;
            }
            // 5bis) Rechazo por cooldown específico del trigger (antes de validar zona)
            if (IsTriggerCooling(trigTag))
            {
                LogSignalCsv(
                    trigTag, up, i,
                    zoneOk: false,
                    reentryBlocked: false,
                    triggerCooling: true,
                    action: "skip",
                    skipReason: RejectCode.TRIGGER_COOLING,
                    dynMinBeyondPips: 0.0,
                    spreadAtSignalPips: spreadAtSig
                );
                return;
            }
            // 6) Validación de zona por trigger
            double triggerPx = _mC;
            bool zoneOK = ZoneOk(trigTag, i, triggerPx);
            // Log de señal con resultado de la zona
            LogSignalCsv(
                trigTag, up, i,
                zoneOk: zoneOK,
                reentryBlocked: false,
                triggerCooling: false,
                action: zoneOK ? "ok" : "skip",
                skipReason: zoneOK ? RejectCode.NONE : RejectCode.ZONE_NOT_OK,
                dynMinBeyondPips: 0.0,
                spreadAtSignalPips: spreadAtSig
            );

            if (!zoneOK) return;
            // 6bis) Embudo + diario
            _tm?.IncSignalValidZone(trigTag);
            _daily?.OnValidSignal(Server.Time);
            // 7) SL y validaciones finales
            double slPips = ComputeSLPipsFromATRAndStructure(up);
            if (slPips <= 0 || slPips > SL_MaxPips)
            {
                LogSignalCsv(
                    trigTag, up, i,
                    zoneOk: true,
                    reentryBlocked: false,
                    triggerCooling: IsTriggerCooling(trigTag),
                    action: "skip",
                    skipReason: RejectCode.SL_ABOVE_MAX,
                    dynMinBeyondPips:
                        (trigTag == "BOS") ? DynMinBeyond(SafeAtrPips(i), Policy.DYN_CLOSE_BEYOND_ATR_BOS) :
                        (trigTag == "FBK") ? DynMinBeyond(SafeAtrPips(i), Policy.DYN_CLOSE_BEYOND_ATR_FBK) :
                        0.0,
                    spreadAtSignalPips: spreadAtSig
                );
                return;
            }
            // 8) Telemetría de conteo por trigger
            if (!string.IsNullOrEmpty(trigTag) && _sigCount.ContainsKey(trigTag))
                _sigCount[trigTag]++;
            // 9) Evita apilar pendientes del mismo lado
            if (EntryMode.Equals("Stop", StringComparison.OrdinalIgnoreCase) && HasPendingSameSide(up))
            {
                LogSignalCsv(
                    trigTag, up, i,
                    zoneOk: true,
                    reentryBlocked: false,
                    triggerCooling: IsTriggerCooling(trigTag),
                    action: "skip",
                    skipReason: RejectCode.PENDING_SAME_SIDE,
                    dynMinBeyondPips: 0.0,
                    spreadAtSignalPips: spreadAtSig
                );
                return;
            }
            // 10) Cooldown por trigger + ejecución
            ArmTriggerCooldown(trigTag);

            if (EntryMode.Equals("Market", StringComparison.OrdinalIgnoreCase))
                ExecuteTemaEntryMarket(up, slPips, trigTag);
            else
                ExecuteTemaEntryStop(up, slPips, trigTag);
        }


        private int CurrentBarIndex() => _barsM5 != null && _barsM5.Count > 0 ? _barsM5.Count - 1 : -1;

        private bool CandleRangeWithinATR(int i, double minAtrMult, double maxAtrMult)
        {
            double range = _barsM5.HighPrices[i] - _barsM5.LowPrices[i];
            if (range <= 0) return false;

            double rangePips = PriceToPips(range);
            double atrPips   = SafeAtrPips(i);
            if (atrPips <= 0) return false;

            double r = rangePips / atrPips;
            return r >= minAtrMult && r <= maxAtrMult;
        }

        private bool CandleRangeAtLeast(int i, double minAtrMult)
        {
            double range = _barsM5.HighPrices[i] - _barsM5.LowPrices[i];
            if (range <= 0) return false;

            double rangePips = PriceToPips(range);
            double atrPips   = SafeAtrPips(i);
            if (atrPips <= 0) return false;

            return (rangePips / atrPips) >= minAtrMult;
        }

        private bool IsTriggerCooling(string tag)
        {
            int i = CurrentBarIndex();
            if (i < 0) return true;
            return i <= (_trigCooldownUntil.TryGetValue(tag, out var until) ? until : -1);
        }

        private void ArmTriggerCooldown(string tag)
        {
            int bars = TriggerCooldownBars;
            if (bars <= 0) return;

            int i = CurrentBarIndex();
            if (i < 0) return;

            _trigCooldownUntil[tag] = i + bars;
            Print($"[CDN] {tag} cooldown {bars} barras (hasta idx {i + bars}).");
        }

        private string ExtractTriggerTag(string label)
        {
            if (string.IsNullOrEmpty(label)) return null;
            int k = label.IndexOf("TRIG=", StringComparison.OrdinalIgnoreCase);
            if (k < 0) return null;
            int start = k + 5;
            int end = label.IndexOf(' ', start);
            string tag = end >= 0 ? label.Substring(start, end - start) : label.Substring(start);
            tag = tag.Trim().ToUpperInvariant();
            return (tag == "BOS" || tag == "ENG" || tag == "PIN" || tag == "FBK" || tag == "MOM") ? tag : null;
        }
        // Construye etiquetas coherentes con TRIG y TP-suffixes
        private (string single, string tp1, string tp2) BuildLabels(string baseTag, string trigTag, string sid = null)
        {
            trigTag = (trigTag ?? "").Trim().ToUpperInvariant();
            string trigPart = string.IsNullOrEmpty(trigTag) ? "" : $" TRIG={trigTag}";
            string sidPart  = string.IsNullOrEmpty(sid) ? "" : $" SID={sid}";

            string core = baseTag.Trim();
            string single = $"{core}{trigPart}{sidPart}";
            string tp1 = $"{core}-TP1{trigPart}{sidPart}";
            string tp2 = $"{core}-TP2{trigPart}{sidPart}";
            return (single, tp1, tp2);
        }
        // Quita la parte " TRIG=XYZ" si ya viene embebida en la etiqueta
        private string RemoveTrigPart(string label)
        {
            if (string.IsNullOrEmpty(label)) return string.Empty;
            int k = label.IndexOf("TRIG=", StringComparison.OrdinalIgnoreCase);
            return k >= 0 ? label.Substring(0, k).TrimEnd() : label.Trim();
        }

        private int GetPendingAgeBars(PendingOrder po, int i)
        {
            if (po == null) return 0;
            int placed;
            // Preferimos Id; si no existe, caemos a label
            if (_poPlacedAtBarById.TryGetValue(po.Id, out placed)) return i - placed;

            var lbl = po.Label ?? string.Empty;
            if (_poPlacedAtBarByLabel.TryGetValue(lbl, out placed)) return i - placed;
            // Primera vez que lo vemos → inicializamos ahora
            _poPlacedAtBarById[po.Id] = i;
            _poPlacedAtBarByLabel[lbl] = i;
            return 0;
        }

        private int IncInvalidStreak(PendingOrder po)
        {
            if (po == null) return 0;
            int v;
            if (_poInvalidStreakById.TryGetValue(po.Id, out v)) v++; else v = 1;
            _poInvalidStreakById[po.Id] = v;

            var lbl = po.Label ?? string.Empty;
            if (!string.IsNullOrEmpty(lbl))
            {
                int vl;
                if (_poInvalidStreakByLabel.TryGetValue(lbl, out vl))
                    _poInvalidStreakByLabel[lbl] = Math.Max(v, vl);
                else
                    _poInvalidStreakByLabel[lbl] = v;
            }
            return v;
        }

        private void ResetInvalidStreak(PendingOrder po)
        {
            if (po == null) return;
            _poInvalidStreakById[po.Id] = 0;
            var lbl = po.Label ?? string.Empty;
            if (!string.IsNullOrEmpty(lbl)) _poInvalidStreakByLabel[lbl] = 0;
        }

        private void RemovePendingTracking(PendingOrder po)
        {
            if (po == null) return;
            _poPlacedAtBarById.Remove(po.Id);
            _poInvalidStreakById.Remove(po.Id);

            var lbl = po.Label ?? string.Empty;
            if (!string.IsNullOrEmpty(lbl))
            {
                _poPlacedAtBarByLabel.Remove(lbl);
                _poInvalidStreakByLabel.Remove(lbl);
            }
        }

        private void MoveSiblingTP2ToBEIfAny(string closedLabel)
        {
            try
            {
                if (!BEAfterTP1) return;
                if (string.IsNullOrEmpty(closedLabel)) return;
                // Trabaja con el “core” (sin el " TRIG=XYZ")
                string core = RemoveTrigPart(closedLabel);
                if (!core.EndsWith("-TP1", StringComparison.Ordinal)) return;
                // Reconstruir la etiqueta de la gemela TP2 con el mismo TRIG=…
                string trig = ExtractTriggerTag(closedLabel);
                string siblingCore  = core.Substring(0, core.Length - "-TP1".Length) + "-TP2";
                string siblingLabel = string.IsNullOrEmpty(trig) ? siblingCore : $"{siblingCore} TRIG={trig}";
                // Buscar la posición TP2 abierta con esa etiqueta
                var tp2 = Positions.FirstOrDefault(p => p.SymbolName == SymbolName &&
                                                        string.Equals(p.Label ?? string.Empty, siblingLabel, StringComparison.Ordinal));
                if (tp2 == null) return;
                // Calcular BE ± pad en pips convertido a precio
                double pad = PipsToPrice(BEPadPipsAfterTP1);
                bool isBuy = tp2.TradeType == TradeType.Buy;
                double bePrice = isBuy ? tp2.EntryPrice + pad : tp2.EntryPrice - pad;
                // No empeorar un SL ya mejor que BE
                double newSL = bePrice;
                if (tp2.StopLoss.HasValue)
                {
                    double curr = tp2.StopLoss.Value;
                    newSL = isBuy ? Math.Max(curr, bePrice) : Math.Min(curr, bePrice);
                }

        #pragma warning disable 618
                ModifyPosition(tp2, newSL, tp2.TakeProfit);
        #pragma warning restore 618

                Print($"[TP1→BE] {siblingLabel}: SL → {(isBuy ? "≥" : "≤")} BE±{BEPadPipsAfterTP1:F1}p (precio {newSL:F5}).");
            }
            catch (Exception ex)
            {
                Print($"[ERR][MoveSiblingTP2ToBEIfAny] {ex.Message}");
            }
        }

        private bool IsTrendAlignedFor(bool up, int i)
        {
            double emaF = _emaFast.Result[i];
            double emaM = _emaMed.Result[i];
            double emaS = _emaSlow.Result[i];

            bool trendOk = up ? (emaF > emaM && emaM > emaS)
                              : (emaF < emaM && emaM < emaS);

            if (!trendOk) return false;
            if (!EmaSeparationPasses(i)) return false;
            return true;
        }
        // Devuelve true si la separación EMA20-EMA50 cumple el umbral (absoluto en pips o relativo a ATR)
        private bool EmaSeparationPasses(int i)
        {
            // Si no se usa filtro de tendencia, no forzamos separación
            if (!UseTrendFilter) return true;
            // Seguridad por si i es inválido
            if (i < 0 || i >= _barsM5.Count) return false;

            double emaM = _emaMed.Result[i];
            double emaS = _emaSlow.Result[i];
            double sepPips = PriceToPips(Math.Abs(emaM - emaS));

            if (UseATRRelativeSeparation)
            {
                double atrPips = SafeAtrPips(i);
                if (atrPips <= 0) return false;               // si ATR inválido, no pasa
                return sepPips >= (EmaSepAtrMult * atrPips);  // separación relativa
            }
            else
            {
                if (MinSeparation_EMA20_EMA50_Pips <= 0.0) return true;
                return sepPips >= MinSeparation_EMA20_EMA50_Pips; // separación absoluta en pips (como antes)
            }
        }
        // Cancela pendientes si se rompe estructura (con suavizados) + telemetría de motivo
        private void CancelPendingsIfStructureInvalid()
        {
            try
            {
                if (PendingOrders == null || PendingOrders.Count == 0) return;

                // Gracia al inicio del día
                if (_barsSinceDayStart <= DayStartGraceBars) return;
                int i = CurrentBarIndex();
                if (i < 0) return;
                // Helpers rápidos y ATR seguro
                var (boxHighMacro, boxLowMacro) = GetReentryBoxHL_Fast(i);
                double atrPipsNow = SafeAtrPips(i);
                if (atrPipsNow <= 0) return;
                // Gracia en pips
                double gPips = CancelGracePips;
                // Umbrales dinámicos (más exigentes para cancelar)
                double dynMinMacroPips = DynMinBeyond(atrPipsNow, Policy.DYN_CLOSE_BEYOND_ATR_FBK) + gPips;
                double c = _barsM5.ClosePrices[i];

                var (boxHighMicro, boxLowMicro) = GetMicroBoxHL_Fast(i);
                double boxRangeMicroPips   = PriceToPips(boxHighMicro - boxLowMicro);
                double microRangeLimitPips = MicroBoxMaxRangeAtrMult * atrPipsNow + gPips;

                var toCancel   = new List<PendingOrder>();
                var reasonById = new Dictionary<long, string>();

                for (int idx = 0; idx < PendingOrders.Count; idx++)
                {
                    var po = PendingOrders[idx];
                    if (po.SymbolName != SymbolName) continue;

                    bool upOrder = (po.TradeType == TradeType.Buy);
                    // 1) Edad mínima
                    int age = GetPendingAgeBars(po, i);
                    if (age < KeepPendingMinBars)
                    {
                        ResetInvalidStreak(po);
                        continue;
                    }
                    // 2) Condiciones de invalidación (suavizadas)
                    bool invalidNow = false;
                    string reasonUsed = null;
                    // 2.a) Tendencia desalineada
                    if (!IsTrendAlignedFor(upOrder, i))
                    {
                        invalidNow = true;
                        if (reasonUsed == null) reasonUsed = "TrendMisaligned";
                    }
                    // 2.b) FBK: retroceso macro más allá + gracia
                    var lbl = po.Label ?? string.Empty;
                    bool isFBK = lbl.IndexOf("TRIG=FBK", StringComparison.OrdinalIgnoreCase) >= 0;
                    if (isFBK)
                    {
                        if (upOrder)
                        {
                            if (c < boxHighMacro - PipsToPrice(dynMinMacroPips))
                            {
                                invalidNow = true;
                                if (reasonUsed == null) reasonUsed = "FBK_OppositeDrift";
                            }
                        }
                        else
                        {
                            if (c > boxLowMacro + PipsToPrice(dynMinMacroPips))
                            {
                                invalidNow = true;
                                if (reasonUsed == null) reasonUsed = "FBK_OppositeDrift";
                            }
                        }
                    }
                    // 2.c) Micro box demasiado ancha
                    if (boxRangeMicroPips > microRangeLimitPips)
                    {
                        invalidNow = true;
                        if (reasonUsed == null) reasonUsed = "MicroBoxTooWide";
                    }
                    // 2.d) Dos cierres opuestos más allá (umbral dinámico + gracia)
                    if (InvalidateOnTwoOppCloses && i >= 2)
                    {
                        double c0 = _barsM5.ClosePrices[i];
                        double c1 = _barsM5.ClosePrices[i - 1];

                        double dynMinMicroPips = DynMinBeyond(atrPipsNow, MicroBoxOppBeyondAtrMult) + gPips;
                        double mid = (boxHighMicro + boxLowMicro) * 0.5;

                        if (upOrder)
                        {
                            double thr = mid - PipsToPrice(dynMinMicroPips);
                            if (c1 < thr && c0 < thr)
                            {
                                invalidNow = true;
                                if (reasonUsed == null) reasonUsed = "TwoOppClosesBeyond";
                            }
                        }
                        else
                        {
                            double thr = mid + PipsToPrice(dynMinMicroPips);
                            if (c1 > thr && c0 > thr)
                            {
                                invalidNow = true;
                                if (reasonUsed == null) reasonUsed = "TwoOppClosesBeyond";
                            }
                        }
                    }
                    // 3) Racha consecutiva requerida
                    if (invalidNow)
                    {
                        int streak = IncInvalidStreak(po);
                        if (streak >= CancelConditionConsecBars)
                        {
                            toCancel.Add(po);
                            reasonById[po.Id] = reasonUsed ?? "StructureInvalid";
                        }
                    }
                    else
                    {
                        ResetInvalidStreak(po);
                    }
                }
                if (toCancel.Count == 0) return;
            // 4) Ejecutar cancelaciones + telemetría
            // Precio “now” para fallback de distancia
            double currNow;
            try
            {
                int li = (_barsM5 != null ? _barsM5.Count - 1 : -1);
                currNow = (li >= 0) ? _barsM5.ClosePrices[li] : (Symbol.Bid + Symbol.Ask) * 0.5;
            }
            catch { currNow = (Symbol.Bid + Symbol.Ask) * 0.5; }

            foreach (var po in toCancel)
            {
                string label = po.Label ?? string.Empty;
                string trig  = ExtractTriggerTag(label) ?? "NA";
                bool   isBuy = (po.TradeType == TradeType.Buy);
                // --- métricas “live” (ANTES de telemetría/CSV)
                double? bestReachPrice = null;
                double? minDistPips    = null;
                if (_liveById.TryGetValue(po.Id, out var live))
                {
                    if (IsFiniteDouble(live.BestReachPrice))
                        bestReachPrice = live.BestReachPrice;

                    if (IsFiniteDouble(live.MinDistPips) && !double.IsInfinity(live.MinDistPips))
                        minDistPips = live.MinDistPips;
                }
                else
                {
                    // Fallback: distancia instantánea a la entrada usando TargetPrice
                    try
                    {
                        if (po.TargetPrice > 0)
                            minDistPips = PriceToPips(Math.Abs(currNow - po.TargetPrice));
                    }
                    catch { /* no-op */ }
                }
                // 1) Motivo crudo -> canónico
                string rawReason   = reasonById.TryGetValue(po.Id, out var r) ? r : "STRUCTURE_INVALID";
                string reasonCanon = Canon.NormalizeCancel(rawReason);
                // 2) Telemetría (string + enum canónico)
                _runAgg?.OnOrderCanceled(trig, reasonCanon);
                _tm?.OnOrderCanceled(trig, isBuy, reasonCanon);
                // 3) orders.csv con motivo canónico
                _orders?.OnCanceled(po.Id.ToString(), Server.Time, reasonCanon, bestReachPrice, minDistPips);
                // 4) Cancelar + limpieza de trackings
                Print("Cancel pending (soft): {0} | reason={1} (raw={2})", label, reasonCanon, rawReason);
                CancelPendingOrderSafe(po);
                
            }
            }
            catch (Exception ex)
            {
                Print($"[ERR][CancelPendingsIfStructureInvalid] {ex.Message}");
            }
        }

        private bool IsBOSMicro(bool up, int lookback)
        {
            int i = _barsM5.Count - 1;
            if (i <= 0) return false;

            int lb = Math.Min(lookback, i);
            if (lb <= 0) return false;

            double refLevel;
            if (up)
            {
                double maxH = double.MinValue;
                for (int x = i - lb; x < i; x++)
                    if (_barsM5.HighPrices[x] > maxH) maxH = _barsM5.HighPrices[x];
                refLevel = maxH;
            }
            else
            {
                double minL = double.MaxValue;
                for (int x = i - lb; x < i; x++)
                    if (_barsM5.LowPrices[x] < minL) minL = _barsM5.LowPrices[x];
                refLevel = minL;
            }

            double close = _barsM5.ClosePrices[i];
            // ATR seguro
            double atrPips = SafeAtrPips(i);
            if (atrPips <= 0) return false;
            // Umbral dinámico “close beyond” para BOS
            double dynMin = DynMinBeyond(atrPips, Policy.DYN_CLOSE_BEYOND_ATR_BOS);
            // Consolidación de corto lookback (BOS)
            var (_, _, consRangePips, consolidated) =
                ConsolidationBox(
                    i,
                    Policy.BOS_CONS_LB_MAX,          // lookback de consolidación
                    atrPips,
                    Policy.CONS_RANGE_MULT_BOS,      // 0.60*ATR por política
                    Policy.BOS_CONS_LB_MAX           // clamp explícito
                );

            // Distancia más allá del nivel de referencia
            double beyondPips = PriceToPips(Math.Abs(close - refLevel));
            // ----- vela de ruptura: cuerpo mínimo y mecha contraria no desproporcionada
            double o = _barsM5.OpenPrices[i], c = _barsM5.ClosePrices[i];
            double h = _barsM5.HighPrices[i],  l = _barsM5.LowPrices[i];
            double range = Math.Max(1e-10, h - l);
            double body  = Math.Abs(c - o);
            double bodyPct = 100.0 * (body / range);
            if (bodyPct < BosMinBodyPct) return false;
            double upperW = h - Math.Max(o, c);
            double lowerW = Math.Min(o, c) - l;
            double oppWick = up ? lowerW : upperW;
            if (body > 0 && (oppWick / body) > BosMaxOppWickBodyMult) return false;
            // Señal válida si supera umbral y hay consolidación
            return (beyondPips >= dynMin) && consolidated;
        }

        private void CancelPendingOrderSafe(PendingOrder po)
        {
            try
            {
                if (po == null) return;

                long   id  = po.Id;
                string lbl = po.Label ?? string.Empty;
                // Cancela en la plataforma (protegido)
                try
                {
                    CancelPendingOrder(po);
                }
                catch (Exception ex)
                {
                    Print($"[ERR][CancelPendingOrder] {ex.Message}");
                }
                // Limpia tracking de edad/rachas por Id/Label
                RemovePendingTracking(po);
                // Elimina expected-entry asociado
                if (!string.IsNullOrEmpty(lbl))
                    _expectedEntryByLabel.Remove(lbl);
                // Limpia tracking “live” (para orders.csv helpers)
                _liveById.Remove(id);
                if (!string.IsNullOrEmpty(lbl))
                    _orderIdByLabel.Remove(lbl);
            }
            catch (Exception ex)
            {
                Print($"[ERR][CancelPendingOrderSafe] {ex.Message}");
            }
        }

        private void PruneCaches(int i)
        {
            try
            {
                // High water marks
                _maxMetricsCache   = Math.Max(_maxMetricsCache, _metricsCache.Count);
                _maxBoxCache       = Math.Max(_maxBoxCache, _boxCache.Count);
                _maxExpectedLabels = Math.Max(_maxExpectedLabels, _expectedEntryByLabel.Count);
                // 1) Métricas: política + hard cap
                if (_metricsCache.Count > Policy.METRICS_CACHE_PRUNE_IF_GT)
                {
                    var keysToRemove = _metricsCache.Keys.Where(k => k < i - Policy.METRICS_CACHE_KEEP_BACK).ToList();
                    foreach (var key in keysToRemove) _metricsCache.Remove(key);
                }
                if (_metricsCache.Count > MAX_METRICS_CACHE)
                {
                    var keysToRemove = _metricsCache.Keys.OrderBy(k => k).Take(_metricsCache.Count - MAX_METRICS_CACHE).ToList();
                    foreach (var key in keysToRemove) _metricsCache.Remove(key);
                }
                // 2) Cajas: política + hard cap
                if (_boxCache.Count > Policy.BOX_CACHE_PRUNE_IF_GT)
                {
                    var keysToRemove = _boxCache.Keys.Where(k => k.Contains("_")).Take(Policy.BOX_CACHE_TRIM_BATCH).ToList();
                    foreach (var key in keysToRemove) _boxCache.Remove(key);
                }
                if (_boxCache.Count > MAX_BOX_CACHE)
                {
                    var keysToRemove = _boxCache.Keys.Take(_boxCache.Count - MAX_BOX_CACHE).ToList();
                    foreach (var key in keysToRemove) _boxCache.Remove(key);
                }
                // 3) Expected entries: mantener solo los vivos + hard cap
                var alive = new HashSet<string>(
                    PendingOrders.Where(po => po.SymbolName == SymbolName).Select(po => po.Label ?? string.Empty)
                );
                var dead = _expectedEntryByLabel.Keys.Where(k => !alive.Contains(k)).ToList();
                foreach (var k in dead) _expectedEntryByLabel.Remove(k);

                if (_expectedEntryByLabel.Count > MAX_EXPECTED)
                {
                    foreach (var k in _expectedEntryByLabel.Keys.Take(_expectedEntryByLabel.Count - MAX_EXPECTED).ToList())
                        _expectedEntryByLabel.Remove(k);
                }
            }
            catch (Exception ex)
            {
                Print($"[ERR][PruneCaches] {ex.Message}");
            }
        }

        private void ResetDayHard()
        {
            _boxCache.Clear();
            _metricsCache.Clear();
            _expectedEntryByLabel.Clear();

            _consecLosses = 0;
            _riskTodayPct = 0.0;
            // cooldown y trigger cooldowns
            _cooldownUntil = DateTime.MinValue;
            _trigCooldownUntil["BOS"] = -1;
            _trigCooldownUntil["ENG"] = -1;
            _trigCooldownUntil["PIN"] = -1;
            _trigCooldownUntil["FBK"] = -1;
            _trigCooldownUntil["MOM"] = -1;
            // bloqueos de reentrada → limpiar completamente
            _blockLong = _blockShort = false;
            _blockHigh = double.NaN;
            _blockLow  = double.NaN;
            _blockUntilBar = -1;
            _blockStartBar = -1;
            // flags de requests (para el patrón single-writer)
            _pendingReentry = 0;
            _pendingCancelPendings = false;
            _pendingCooldownUntil = DateTime.MinValue;
            // histéresis (para evitar quedar “atascados” tras la medianoche)
            _spreadOkPrev = true;
            _atrOkPrev = true;
            ResetDayLevels(); // PDH/PDL/Asia
        }

        private (double boxHigh, double boxLow) GetReentryBoxHL_Fast(int i)
        {
            double h = _mxReentryHigh?.CurrentMax(i) ?? double.NaN;
            double l = _mnReentryLow?.CurrentMin(i) ?? double.NaN;
            if (double.IsNaN(h) || double.IsNaN(l))
                return GetBoxHL(i, Math.Max(3, ReentryBoxLB)); // fallback a tu método actual
            return (h, l);
        }

        private (double boxHigh, double boxLow) GetMicroBoxHL_Fast(int i)
        {
            double h = _mxMicroHigh?.CurrentMax(i) ?? double.NaN;
            double l = _mnMicroLow?.CurrentMin(i) ?? double.NaN;
            if (double.IsNaN(h) || double.IsNaN(l))
                return GetBoxHL(i, Math.Max(3, MicroBoxLB));
            return (h, l);
        }

        private bool ZoneOk(string trig, int i, double triggerPrice)
        {
            if (i < 0 || i >= _barsM5.Count) return false;
            // Política por trigger
            string policy = trig switch
            {
                "BOS" => ZonePolicy_BOS,
                "FBK" => ZonePolicy_FBK,
                "ENG" => ZonePolicy_ENG,
                "PIN" => ZonePolicy_PIN,
                "MOM" => ZonePolicy_MOM,
                _     => "EMA"
            };
            // ATR (para tolerancias dinámicas)
            double atrPips = SafeAtrPips(i);
            if (atrPips <= 0) return false;
            // Tolerancias:
            // - banda del canal EMA20–EMA50 (fudge más amplio)
            double tolBandPips  = Math.Min(Policy.NEAR_EMA_BAND_MAX_PIPS,
                                           Policy.NEAR_EMA_BAND_ATR_MULT * atrPips);
            // - cercanía a EMA20 (requisito principal): 0.30×ATR cap a máx NEAR_EMA_BAND_MAX_PIPS
            double tolEma20Pips = Math.Min(Policy.NEAR_EMA_BAND_MAX_PIPS, 0.30 * atrPips);
            // EMAs
            double emaF = _emaFast.Result[i];
            double emaM = _emaMed.Result[i]; // EMA20
            double emaS = _emaSlow.Result[i]; // EMA50
            // Tendencia (por si se exige canal “en dirección”)
            bool up = emaF > emaM && emaM > emaS;
            bool dn = emaF < emaM && emaM < emaS;
            // Canal EMA20–EMA50 con tolerancia
            double lo = Math.Min(emaM, emaS) - PipsToPrice(tolBandPips);
            double hi = Math.Max(emaM, emaS) + PipsToPrice(tolBandPips);
            bool inChannel = triggerPrice >= lo && triggerPrice <= hi;
            // Si se usa filtro de tendencia, imponemos estar del lado correcto del canal
            if (UseTrendFilter)
            {
                if (!(up || dn)) return false; // sin tendencia clara, no hay zona
                if (up && triggerPrice < (emaS - PipsToPrice(tolBandPips))) inChannel = false; // muy por debajo de EMA50
                if (dn && triggerPrice > (emaS + PipsToPrice(tolBandPips))) inChannel = false; // muy por encima de EMA50
            }
            // Cercanía a EMA20 (núcleo de “zona de valor”)
            bool nearEma20 = Math.Abs(triggerPrice - emaM) <= PipsToPrice(tolEma20Pips);
            // Niveles (PDH/PDL/Asia/RN…) según tus flags actuales
            bool nearLevel = IsNearAnyActiveLevel(triggerPrice, LevelProximityPips);
            // Si el usuario exige proximidad a nivel, abortar si no se cumple
            if (RequireProximityToLevel && !nearLevel)
                return false;
            // EMA-OK = cerca de EMA20 y dentro del canal 20–50
            bool emaOK = nearEma20 && inChannel;

            switch ((policy ?? "EMA").ToUpperInvariant())
            {
                case "EMA":    return emaOK;
                case "LEVEL":  return nearLevel;
                case "BOTH":   return emaOK && nearLevel;
                case "EITHER":
                default:       return emaOK || nearLevel;
            }
        }


        private bool HasPendingSameSide(bool up)
        {
            if (PendingOrders == null || PendingOrders.Count == 0) return false;

            var tt = up ? TradeType.Buy : TradeType.Sell;

            for (int i = 0; i < PendingOrders.Count; i++)
            {
                var po = PendingOrders[i];
                if (po.SymbolName == SymbolName && po.TradeType == tt)
                    return true;
            }
            return false;
        }

        private bool IsEngulfing(bool up)
        {
            int i = _barsM5.Count - 1;
            if (i < 1) return false;

            double o = _barsM5.OpenPrices[i],  c = _barsM5.ClosePrices[i];
            double po = _barsM5.OpenPrices[i - 1], pc = _barsM5.ClosePrices[i - 1];
            double h = _barsM5.HighPrices[i],   l = _barsM5.LowPrices[i];

            double body = Math.Abs(c - o), range = h - l;
            if (range <= 0) return false;
            double bodyPct = 100.0 * (body / range);

            bool bullEng = (c > o) && (pc < po) && (c >= po) && (o <= pc);
            bool bearEng = (c < o) && (pc > po) && (c <= po) && (o >= pc);
            bool pattern = up ? bullEng : bearEng;
            if (!pattern) return false;

            double atrPips = PriceToPips(_atr.Result[i]);
            double rangePips = PriceToPips(range);
            if (bodyPct < Math.Max(Policy.ENG_BODY_FLOOR_PCT, BodyPct)) return false;
            if (rangePips < Policy.ENG_RANGE_MIN_ATR_MULT * atrPips) return false;

            if (!ZoneOk("ENG", i, c)) return false;

            return true;
        }

        private bool IsPinBar(bool up, int wickPct)
        {
            int i = _barsM5.Count - 1;
            double h = _barsM5.HighPrices[i], l = _barsM5.LowPrices[i];
            double o = _barsM5.OpenPrices[i], c = _barsM5.ClosePrices[i];

            double body = Math.Abs(c - o), range = h - l;
            if (range <= 0) return false;

            double upperWick = h - Math.Max(o, c);
            double lowerWick = Math.Min(o, c) - l;
            double refWick = up ? lowerWick : upperWick;

            double wickPercent = 100.0 * (refWick / range);
            if (wickPercent < Math.Max(60, wickPct)) return false;

            if (body == 0 || (refWick / body) < Policy.PIN_WICK_TO_BODY_MIN) return false;

            double atrPips = PriceToPips(_atr.Result[i]);
            double rangePips = PriceToPips(range);
            if (rangePips < Policy.PIN_RANGE_MIN_ATR_MULT * atrPips) return false;

            if (!ZoneOk("PIN", i, c)) return false;

            return true;
        }
        // =========================
        //     MOMENTUM SNAP (M5)
        // =========================
        private void TryMomentumSnap()
        {
            // 0) Cooldown específico del trigger MOM
            if (IsTriggerCooling("MOM"))
            {
                int ii = _barsM5.Count - 1;
                if (ii >= 0)
                {
                    RefreshBarMetrics(ii);
                    LogSignalCsv(
                        "MOM", /*up*/ _mC > _mO, ii,
                        zoneOk: false,
                        reentryBlocked: false,
                        triggerCooling: true,
                        action: "skip",
                        skipReason: RejectCode.TRIGGER_COOLING,
                        dynMinBeyondPips: 0.0
                    );
                }
                return;
            }

            int i = _barsM5.Count - 1;
            if (i < 1) return;

            RefreshBarMetrics(i);
            if (_mAtrPips <= 0) return;
            // Dirección de la vela actual
            bool up = _mC > _mO;
            bool dn = _mC < _mO;
            if (!up && !dn) return;
            // 1) Reentry block (cuenta y loguea la señal bloqueada)
            if (IsReentryBlocked(up))
            {
                try { _tm?.IncReentryBlocked("MOM", up); } catch { /* no-op */ }
                LogSignalCsv(
                    "MOM", up, i,
                    zoneOk: false,
                    reentryBlocked: true,
                    triggerCooling: false,
                    action: "skip",
                    skipReason: RejectCode.REENTRY_BLOCKED,
                    dynMinBeyondPips: 0.0
                );
                return;
            }
            // 2) Condiciones MomentumSnap
            double bodyPct   = _mBodyPct;
            bool   bigRange  = _mRangePips >= K_ATR * _mAtrPips;
            double slopePips = _mEma20SlopePips;

            if (!(bodyPct >= BodyPct && bigRange && slopePips >= Slope_EMA20_Min_PipsPerBar))
                return;
            // 3) Confirmaciones extra (si procede)
            if (ConfirmBars > 1)
            {
                bool ok = true;
                for (int k = 0; k < ConfirmBars; k++)
                {
                    int idx = i - k; if (idx < 0) { ok = false; break; }
                    double oc = _barsM5.ClosePrices[idx] - _barsM5.OpenPrices[idx];
                    if (up && oc <= 0) { ok = false; break; }
                    if (dn && oc >= 0) { ok = false; break; }
                }
                if (!ok) return;
            }
            // 4) Candidato → embudo
            _tm?.IncSignalCandidate("MOM");
            // 5) Validación de zona
            bool zoneOK = ZoneOk("MOM", i, _mC);
            double spreadAtSig = (Symbol.Ask - Symbol.Bid) / Symbol.PipSize;  // pips actuales
            // Log de la señal (antes de decidir)
            LogSignalCsv(
                "MOM", up, i,
                zoneOk: zoneOK,
                reentryBlocked: false,
                triggerCooling: false,
                action: zoneOK ? "ok" : "skip",
                skipReason: zoneOK ? RejectCode.NONE : RejectCode.ZONE_NOT_OK,
                dynMinBeyondPips: 0.0,
                spreadAtSignalPips: spreadAtSig
            );

            if (!zoneOK) return;
            // 5bis) Embudo + diario
            _tm?.IncSignalValidZone("MOM");
            _daily?.OnValidSignal(Server.Time);
            // 6) SL y validaciones finales
            double slPips = ComputeSLPipsFromATRAndStructure(up);
            if (slPips <= 0 || slPips > SL_MaxPips)
            {
                LogSignalCsv(
                    "MOM", up, i,
                    zoneOk: true,
                    reentryBlocked: false,
                    triggerCooling: false,
                    action: "skip",
                    skipReason: RejectCode.SL_ABOVE_MAX,
                    dynMinBeyondPips: 0.0
                );
                return;
            }
            // 7) Telemetría de conteo por trigger
            if (_sigCount.ContainsKey("MOM")) _sigCount["MOM"]++;
            // 8) Evitar apilar pendientes del mismo lado en modo Stop
            if (EntryMode.Equals("Stop", StringComparison.OrdinalIgnoreCase) && HasPendingSameSide(up))
            {
                LogSignalCsv(
                    "MOM", up, i,
                    zoneOk: true,
                    reentryBlocked: false,
                    triggerCooling: false,
                    action: "skip",
                    skipReason: RejectCode.PENDING_SAME_SIDE,
                    dynMinBeyondPips: 0.0
                );
                return;
            }
            // 9) Cooldown de trigger tras confirmarse + ejecución
            ArmTriggerCooldown("MOM");

            if (EntryMode.Equals("Stop", StringComparison.OrdinalIgnoreCase))
            {
                // Delega en tu flujo estándar de Stop (usa PlaceStopOrderSplit internamente)
                ExecuteTemaEntryStop(up, slPips, "MOM");
            }
            else
            {
                ExecuteTemaEntryMarket(up, slPips, "MOM");
            }
        }
        // =========================
        //     ENTRADAS & ÓRDENES
        // =========================
        /// === MARKET ===
        private void ExecuteTemaEntryMarket(bool up, double slPips, string trigTag)
        {
            int i = CurrentBarIndex();
            string sid = GenerateSignalId(i, trigTag, up);
            ExecuteTemaEntryMarket(up, slPips, trigTag, sid);
        }

        private void ExecuteTemaEntryMarket(bool up, double slPips, string trigTag, string sid)
        {
            if (HasOpenSameSide(up)) return;

            var (tp1Pips, tp2Pips) = ComputeTPs(slPips);
            double volUnits = ComputePositionSizeUnits(slPips, RiskPerTradePct);
            if (volUnits <= 0) return;

            var (labelSingle, labelTP1, labelTP2) = BuildLabels("TEMA-MKT", trigTag);
            labelSingle = WithSid(labelSingle, sid);
            labelTP1    = WithSid(labelTP1, sid);
            labelTP2    = WithSid(labelTP2, sid);
            // snapshot de “expected entry” (para medir slippage al fill)
            double expectedEntry = up ? Symbol.Ask : Symbol.Bid;
            // Telemetría “placed” (canal Market) + conteo por trigger
            _tm?.OnOrderPlaced(trigTag, up, "Market");
            _tm?.IncOrderPlaced(up);
            _runAgg?.OnOrderPlaced(trigTag);
            // snapshot de estado para orders.csv (mismo formato que STOP)
            int bi = _barsM5.Count - 1;
            bool trendOk   = IsTrendAlignedFor(up, bi);
            var (reH, reL) = GetReentryBoxHL_Fast(bi);
            var (miH, miL) = GetMicroBoxHL_Fast(bi);
            string boxState = $"re=[{reH:F5},{reL:F5}];mi=[{miH:F5},{miL:F5}]";

            if (EnableTP1 && EnableTP2 && PartialCloseTP1Pct > 0 && PartialCloseTP1Pct < 100)
            {
                double vol1 = volUnits * (PartialCloseTP1Pct / 100.0);
                double vol2 = volUnits - vol1;
                // expected per leg (para slippage al fill)
                _expectedEntryByLabel[labelTP1] = expectedEntry;
                _expectedEntryByLabel[labelTP2] = expectedEntry;
                // ► orders.csv “placed” (canal MARKET) usando el helper del #5
                RegisterPlacementCommon(
                    orderIdStr: MakeMarketOrderId(labelTP1),
                    signalId: sid,              
                    label: labelTP1,
                    typeStr: "MARKET",
                    isBuy: up,
                    entryPrice: expectedEntry,
                    slPips: slPips,
                    tpPips: tp1Pips,
                    entryBufPips: 0.0,
                    trendOkAtPlace: trendOk,
                    boxStateAtPlace: boxState
                );
                _marketOrderIdByLabel[labelTP1] = MakeMarketOrderId(labelTP1);
                _orderIdByLabel[labelTP1] = 0;
                RegisterPlacementCommon(
                    orderIdStr: MakeMarketOrderId(labelTP2),
                    signalId: sid,
                    label: labelTP2,
                    typeStr: "MARKET",
                    isBuy: up,
                    entryPrice: expectedEntry,
                    slPips: slPips,
                    tpPips: tp2Pips,
                    entryBufPips: 0.0,
                    trendOkAtPlace: trendOk,
                    boxStateAtPlace: boxState
                );
                _marketOrderIdByLabel[labelTP2] = MakeMarketOrderId(labelTP2);
                _orderIdByLabel[labelTP2] = 0;
                ExecuteMarket(up, vol1, slPips, tp1Pips, labelTP1);
                ExecuteMarket(up, vol2, slPips, tp2Pips, labelTP2);
            }
            else
            {
                double tp = (EnableTP2 ? tp2Pips : (EnableTP1 ? tp1Pips : 0.0));

                _expectedEntryByLabel[labelSingle] = expectedEntry;
                
                RegisterPlacementCommon(
                    orderIdStr: MakeMarketOrderId(labelSingle),
                    signalId: sid,
                    label: labelSingle,
                    typeStr: "MARKET",
                    isBuy: up,
                    entryPrice: expectedEntry,
                    slPips: slPips,
                    tpPips: tp,
                    entryBufPips: 0.0,
                    trendOkAtPlace: trendOk,
                    boxStateAtPlace: boxState
                );
                _marketOrderIdByLabel[labelSingle] = MakeMarketOrderId(labelSingle);
                _orderIdByLabel[labelSingle] = 0;
                ExecuteMarket(up, volUnits, slPips, tp, labelSingle);
            }
        }
        // === STOP ===
        private void ExecuteTemaEntryStop(bool up, double slPips, string trigTag)
        {
            int i = CurrentBarIndex();
            string sid = GenerateSignalId(i, trigTag, up);
            ExecuteTemaEntryStop(up, slPips, trigTag, sid);
        }

        private void ExecuteTemaEntryStop(bool up, double slPips, string trigTag, string sid)
        {
            if (HasOpenSameSide(up)) return;

            int i = _barsM5.Count - 1;
            RefreshBarMetrics(i);

            double trigger = up ? _barsM5.HighPrices[i] : _barsM5.LowPrices[i];
            double entry   = up ? trigger + PipsToPrice(_mEntryBufPips)
                                : trigger - PipsToPrice(_mEntryBufPips);

            if (HasPendingSameSide(up))
            {
                var side = up ? TradeType.Buy : TradeType.Sell;
                var toCancel = new List<PendingOrder>();
                for (int idx = 0; idx < PendingOrders.Count; idx++)
                {
                    var po = PendingOrders[idx];
                    if (po.SymbolName == SymbolName && po.TradeType == side) toCancel.Add(po);
                }
                foreach (var po in toCancel) CancelPendingOrderSafe(po);
               
                return;
            }

            PlaceStop(up, entry, slPips, $"TEMA-STP TRIG={trigTag}", sid);
        }



        private double ComputeEntryBufferPips(int barIndex)
        {
            double atrPips = SafeAtrPips(barIndex);
            return ComputeEntryBufferFromAtr(atrPips);
        }

        private void PlaceStop(bool up, double entryPrice, double slPips, string tag)
        {
            int i = CurrentBarIndex();
            string trigTag = ExtractTriggerTag(tag);
            string sid = GenerateSignalId(i, trigTag, up);
            PlaceStop(up, entryPrice, slPips, tag, sid);
        }

        private void PlaceStop(bool up, double entryPrice, double slPips, string tag, string sid)
        {
            var (tp1Pips, tp2Pips) = ComputeTPs(slPips);
            double volUnits = ComputePositionSizeUnits(slPips, RiskPerTradePct);
            if (volUnits <= 0) return;

            string trigTag  = ExtractTriggerTag(tag);
            string baseTag  = RemoveTrigPart(tag);
            var (labelSingle, labelTP1, labelTP2) = BuildLabels(baseTag, trigTag);
            labelSingle = WithSid(labelSingle, sid);
            labelTP1    = WithSid(labelTP1, sid);
            labelTP2    = WithSid(labelTP2, sid);

            var type = up ? TradeType.Buy : TradeType.Sell;

            if (EnableTP1 && EnableTP2 && PartialCloseTP1Pct > 0 && PartialCloseTP1Pct < 100)
            {
                double vol1 = volUnits * (PartialCloseTP1Pct / 100.0);
                double vol2 = volUnits - vol1;

                _expectedEntryByLabel[labelTP1] = entryPrice;
                _expectedEntryByLabel[labelTP2] = entryPrice;

                PlaceStopOrderSplit(type, vol1, entryPrice, slPips, tp1Pips, labelTP1, sid);
                PlaceStopOrderSplit(type, vol2, entryPrice, slPips, tp2Pips, labelTP2, sid);
            }
            else
            {
                double tp = (EnableTP2 ? tp2Pips : (EnableTP1 ? tp1Pips : 0.0));

                _expectedEntryByLabel[labelSingle] = entryPrice;
                PlaceStopOrderSplit(type, volUnits, entryPrice, slPips, tp, labelSingle, sid);
            }
        }

        private void PlaceStopOrderSplit(TradeType type, double volumeUnits, double entryPrice, double slPips, double tpPips, string label, string sid)
        {
            var expiration = Server.Time.AddMinutes(TriggerTimeoutBars * Policy.TRIGGER_TIMEOUT_SCALE_MIN);

            var result = PlaceStopOrder(type, SymbolName, NormalizeVolume(volumeUnits), entryPrice, label, slPips, tpPips, expiration);
            // evita doble señal en la misma barra (siempre)
            _lastSignalBarIndex = _barsM5.Count - 1;
            _signalFiredThisBar = true;

            if (result.IsSuccessful && result.PendingOrder != null)
            {
                var po = result.PendingOrder;
                int bi = _barsM5.Count - 1;
                // ► tracking por LABEL (edad/racha) — SOLO si hubo éxito
                _poPlacedAtBarByLabel[label] = bi;
                _poInvalidStreakByLabel[label] = 0;
                // ► expected entry (slippage al fill) — SOLO si hubo éxito
                _expectedEntryByLabel[label] = entryPrice;
                // ► punto 2/7: placed por trigger + TM — SOLO si hubo éxito
                string trig = ExtractTriggerTag(label) ?? "NA";
                _runAgg?.OnOrderPlaced(trig);
                try { _tm?.OnOrderPlaced(trig, type == TradeType.Buy, "Stop"); } catch { /* no-op */ }
                // ► tracking por ID (edad/racha)
                _poPlacedAtBarById[po.Id] = bi;
                _poInvalidStreakById[po.Id] = 0;
                // ► TTF / best-reach / min-dist (arranca desde entryPrice)
                _orderIdByLabel[label] = po.Id;
                _liveById[po.Id] = new OrderLive
                {
                    Label = label,
                    IsBuy = (type == TradeType.Buy),
                    EntryPrice = entryPrice,
                    BestReachPrice = entryPrice,
                    MinDistPips = double.PositiveInfinity,
                    TimePlaced = Server.Time
                };
                // ► orders.csv (fila “placed”)
                bool trendOk = IsTrendAlignedFor(type == TradeType.Buy, bi);
                var (reH, reL) = GetReentryBoxHL_Fast(bi);
                var (miH, miL) = GetMicroBoxHL_Fast(bi);
                string boxState = $"re=[{reH:F5},{reL:F5}];mi=[{miH:F5},{miL:F5}]";

                RegisterPlacementCommon(
                orderIdStr: po.Id.ToString(),
                signalId: sid,
                label: label,
                typeStr: "STOP",
                isBuy: (type == TradeType.Buy),
                entryPrice: entryPrice,
                slPips: slPips,
                tpPips: tpPips,
                entryBufPips: _mEntryBufPips,
                trendOkAtPlace: trendOk,
                boxStateAtPlace: boxState
                );

            }
            else
            {
                // Fallo al colocar — NO dejes residuos
                Print("Stop order failed: {0}", result.Error);
                // Limpieza defensiva (por si se setearon antes en alguna refactor futura)
                _poPlacedAtBarByLabel.Remove(label);
                _poInvalidStreakByLabel.Remove(label);
                _expectedEntryByLabel.Remove(label);
                _orderIdByLabel.Remove(label);
                // _liveById: no hay id si falla, así que nada que borrar aquí
            }
        }
     
        private (double boxHigh, double boxLow) GetBoxHL(int i, int lb)
        {
            string key = $"{i}_{lb}";

            if (_boxCache.TryGetValue(key, out var cached) && cached.calculatedAt == i)
                return (cached.high, cached.low);

            int from = Math.Max(0, i - lb + 1);
            double hi = double.MinValue;
            double lo = double.MaxValue;

            for (int x = from; x <= i; x++)
            {
                if (_barsM5.HighPrices[x] > hi) hi = _barsM5.HighPrices[x];
                if (_barsM5.LowPrices[x] < lo) lo = _barsM5.LowPrices[x];
            }

            _boxCache[key] = (hi, lo, i);
            return (hi, lo);
        }

        private bool IsReentryBlocked(bool up)
        {
            int i = CurrentBarIndex();
            if (i < 0) return false;

            if (i > _blockUntilBar) { _blockLong = _blockShort = false; }

            bool blocked = up ? _blockLong : _blockShort;
            if (!blocked) return false;

            double pad   = PipsToPrice(ReentryBoxPadPips);
            double price = _barsM5.ClosePrices[i];

            bool inside = (price <= _blockHigh + pad) && (price >= _blockLow - pad);
            if (!inside) return false;

            if (UnblockOnOppBreak)
            {
                double atrPips = SafeAtrPips(i);
                if (atrPips > 0)
                {
                    double dynMin = DynMinBeyond(atrPips, Policy.DYN_CLOSE_BEYOND_ATR_FBK);

                    if (up)
                    {
                        double beyond = PriceToPips(Math.Abs(price - _blockLow));
                        if (price < _blockLow && beyond >= dynMin) { _blockLong = false; return false; }
                    }
                    else
                    {
                        double beyond = PriceToPips(Math.Abs(price - _blockHigh));
                        if (price > _blockHigh && beyond >= dynMin) { _blockShort = false; return false; }
                    }
                }
            }
            // --- Auto-unblock por tiempo (caduca tras N barras)
            if (ReentryAutoUnblockBars > 0 && _blockStartBar >= 0)
            {
                int age = i - _blockStartBar;
                if (age >= ReentryAutoUnblockBars)
                {
                    _blockLong = _blockShort = false;
                    _blockStartBar = -1;
                    return false;
                }
            }
            // --- Auto-unblock por "deriva" (si el precio se aleja a favor × ATR)
            double atrPipsForDrift = SafeAtrPips(i);
            if (atrPipsForDrift > 0)
            {
                double thrPrice = PipsToPrice(Math.Max(0.0, ReentryDriftUnblockAtrMult) * atrPipsForDrift);

                if (_blockLong && !double.IsNaN(_blockHigh) && _barsM5.ClosePrices[i] > _blockHigh + thrPrice)
                {
                    _blockLong = false; _blockStartBar = -1; return false;
                }
                if (_blockShort && !double.IsNaN(_blockLow) && _barsM5.ClosePrices[i] < _blockLow - thrPrice)
                {
                    _blockShort = false; _blockStartBar = -1; return false;
                }
            }

            return true;
        }

        private void ArmReentryBlock(bool wasLong)
        {
            int i = CurrentBarIndex();
            if (i < 0) return;

            var (bh, bl) = GetReentryBoxHL_Fast(i);

            _blockHigh = bh;
            _blockLow  = bl;
            _blockUntilBar = i + Math.Max(0, ReentryBlockBars);

            if (wasLong) _blockLong = true; else _blockShort = true;

            _blockStartBar = i; // <<< aquí
        }

        private void ExecuteMarket(bool up, double volumeUnits, double slPips, double tpPips, string label)
        {
            if (HasOpenSameSide(up))
                return;

            var type = up ? TradeType.Buy : TradeType.Sell;

            double expected = up ? Symbol.Ask : Symbol.Bid;

            var result = ExecuteMarketOrder(type, SymbolName, NormalizeVolume(volumeUnits), label, slPips, tpPips);
           if (!result.IsSuccessful)
            {
                Print("Market order failed: {0}", result.Error);

                // NUEVO: cerrar la fila 'placed' como 'canceled'
                try
                {
                    string oid = MakeMarketOrderId(label); // es el mismo ID sintético que usaste al 'placed'
                    _orders?.OnCanceled(oid, Server.Time, "PLACE_FAILED", null, null);
                }
                catch { /* no-op */ }

                // Limpieza defensiva para que no queden residuos
                _expectedEntryByLabel.Remove(label);
                _marketOrderIdByLabel.Remove(label);
                _orderIdByLabel.Remove(label);

                return;
            }

           
            if (result.Position != null)
            {
                // Usar evaluador unificado; pide cooldown/cancel vía Request* (single-writer)
                if (EvaluateSlippageAndMaybeClose(result.Position, label, expectedEntry: expected, isStopOrder: false))
                {
                    _lastSignalBarIndex = _barsM5.Count - 1;
                    _signalFiredThisBar = true;
                    return;
                }
            }

            _lastSignalBarIndex = _barsM5.Count - 1;
            _signalFiredThisBar = true;
        }

        private void CancelAllPendingsIfAny(TelemetryFunnel.CancelReason reason)
        {
            try
            {
                if (PendingOrders == null || PendingOrders.Count == 0) return;

                var list = PendingOrders.Where(po => po.SymbolName == SymbolName).ToList();
                if (list.Count == 0) return;
                // Motivo canónico (una sola vez)
                string reasonCanon = Canon.NormalizeCancel(reason.ToString());
                // Precio “ahora” por si necesitamos fallback para distancia
                double currNow;
                try
                {
                    int li = (_barsM5 != null ? _barsM5.Count - 1 : -1);
                    currNow = (li >= 0) ? _barsM5.ClosePrices[li] : (Symbol.Bid + Symbol.Ask) * 0.5;
                }
                catch { currNow = (Symbol.Bid + Symbol.Ask) * 0.5; }

                foreach (var po in list)
                {
                    string label = po.Label ?? string.Empty;
                    string trig  = ExtractTriggerTag(label) ?? "NA";
                    bool   isBuy = (po.TradeType == TradeType.Buy);

                    // --- métricas “live” para orders.csv (si las tenemos)
                    double? bestReachPrice = null;
                    double? minDistPips    = null;

                    if (_liveById.TryGetValue(po.Id, out var live))
                    {
                        if (IsFiniteDouble(live.BestReachPrice))
                            bestReachPrice = live.BestReachPrice;

                        if (IsFiniteDouble(live.MinDistPips) && !double.IsInfinity(live.MinDistPips))
                            minDistPips = live.MinDistPips;
                    }
                    else
                    {
                        // fallback: distancia instantánea a la entrada
                        try
                        {
                            if (po.TargetPrice > 0)
                            {
                                double dist = PriceToPips(Math.Abs(currNow - po.TargetPrice));
                                minDistPips = dist;
                            }
                        }
                        catch { /* no-op */ }
                    }

                    // --- agregadores / telemetría
                    _runAgg?.OnOrderCanceled(trig, reasonCanon);                         // por trigger
                    _tm?.IncOrderCanceled(reason);
                    _tm?.OnOrderCanceled(trig, isBuy, reasonCanon);                      // motivo string

                    // --- orders.csv: cerrar fila como "canceled"
                    _orders?.OnCanceled(po.Id.ToString(), Server.Time, reasonCanon, bestReachPrice, minDistPips);

                    // --- cancelar en la plataforma + limpiar trackings internos
                    CancelPendingOrderSafe(po);
                    _orderIdByLabel.Remove(label);  
                    _liveById.Remove(po.Id);
                }
            }
            catch (Exception ex)
            {
                Print($"[ERR][CancelAllPendingsIfAny] {ex.Message}");
            }
        }
    
        private void CancelAllPendingsIfAny()
        {
            CancelAllPendingsIfAny(TelemetryFunnel.CancelReason.Manual);
        }

        private enum SlipMode { Off, Lenient, Strict }

        private SlipMode GetSlipMode()
        {
            var s = (SlippagePolicy ?? "Strict").Trim().ToUpperInvariant();
            if (s == "OFF") return SlipMode.Off;
            if (s == "LENIENT") return SlipMode.Lenient;
            return SlipMode.Strict;
        }


        private double ComputeSlipCapPips(int i)
        {
            double cap = SlippageMaxPips;
            double atr = SafeAtrPips(i);
            if (SlippageMaxAtrMult > 0.0 && atr > 0.0)
                cap = Math.Max(cap, SlippageMaxAtrMult * atr);
            return cap;
        }
        // Devuelve true si CERRO la posición por slippage (y solicita cooldown/cancel)
        private bool EvaluateSlippageAndMaybeClose(Position pos, string label, double expectedEntry, bool isStopOrder)
        {
            if (pos == null) return false;
            // ¿Aplicamos según tipo?
            if (isStopOrder && !SlippageApplyToStop) return false;
            if (!isStopOrder && !SlippageApplyToMarket) return false;

            var mode = GetSlipMode();
            if (mode == SlipMode.Off) return false;

            bool isBuy = pos.TradeType == TradeType.Buy;
            double filled = pos.EntryPrice;
            // pips de slippage con signo positivo = adverso
            double signedSlipPips = PriceToPips(isBuy ? (filled - expectedEntry) : (expectedEntry - filled));
            double slipAbs = Math.Abs(signedSlipPips);
            bool adverse = signedSlipPips > 0.0;

            if (!adverse) return false; // slippage a favor, no hacemos nada

            int i = CurrentBarIndex();
            double cap = ComputeSlipCapPips(i);
            // STRICT: si excede el cap, cerrar sí o sí
            if (mode == SlipMode.Strict)
            {
                if (slipAbs > cap)
                {
                    Print($"[SLIP/{(isStopOrder ? "STP" : "MKT")}] {label} adverse={slipAbs:F1}p > cap={cap:F1}p → close & cooldown");
                    ClosePosition(pos);
                    RequestCooldownUntil(Server.Time.AddMinutes(SlippageCooldownMin));
                    RequestCancelAllPendings(TelemetryFunnel.CancelReason.SlippageAdverse);
                    _daily?.OnCooldown("SlippageAdverse");
                    return true;
                }
                return false;
            }
            // LENIENT: sólo cierra si además deja el R-to-TP por debajo del umbral
            // (si no hay TP, actuamos como STRICT)
            double slDistPips = (pos.StopLoss.HasValue) ? PriceToPips(Math.Abs(pos.EntryPrice - pos.StopLoss.Value)) : 0.0;
            double tpDistPips = (pos.TakeProfit.HasValue) ? PriceToPips(Math.Abs(pos.TakeProfit.Value - pos.EntryPrice)) : 0.0;

            if (tpDistPips <= 0.0 || slDistPips <= 0.0)
            {
                // sin TP/SL no podemos evaluar R: usar comportamiento STRICT
                if (slipAbs > cap)
                {
                    Print($"[SLIP/{(isStopOrder ? "STP" : "MKT")}-LENIENT] {label} adverse={slipAbs:F1}p > cap={cap:F1}p (no TP/SL) → close & cooldown");
                    ClosePosition(pos);
                    RequestCooldownUntil(Server.Time.AddMinutes(SlippageCooldownMin));
                    RequestCancelAllPendings(TelemetryFunnel.CancelReason.SlippageAdverse);
                    _daily?.OnCooldown("SlippageAdverse");
                    return true;
                }
                return false;
            }

            double rToTP = tpDistPips / slDistPips;
            if (slipAbs > cap && rToTP < MinRAfterSlip)
            {
                Print($"[SLIP/{(isStopOrder ? "STP" : "MKT")}-LENIENT] {label} adverse={slipAbs:F1}p > cap={cap:F1}p & R={rToTP:F2} < {MinRAfterSlip:F2} → close & cooldown");
                ClosePosition(pos);
                RequestCooldownUntil(Server.Time.AddMinutes(SlippageCooldownMin));
                RequestCancelAllPendings(TelemetryFunnel.CancelReason.SlippageAdverse);
                _daily?.OnCooldown("SlippageAdverse");
                return true;
            }
            // Si llega aquí: toleramos la entrada pero dejamos constancia
            Print($"[SLIP/{(isStopOrder ? "STP" : "MKT")}-LENIENT] {label} adverse={slipAbs:F1}p (cap={cap:F1}p, R={rToTP:F2}) → mantener");
            return false;
        }
        // Cuenta expiraciones y limpia la pending (timeout)
        private void CheckPendingExpirations()
        {
            try
            {
                if (PendingOrders == null || PendingOrders.Count == 0) return;

                var toExpire = new List<PendingOrder>();
                DateTime now = Server.Time;

                for (int i = 0; i < PendingOrders.Count; i++)
                {
                    var po = PendingOrders[i];
                    if (po.SymbolName != SymbolName) continue;
                    if (po.ExpirationTime.HasValue && now >= po.ExpirationTime.Value)
                        toExpire.Add(po);
                }

                if (toExpire.Count == 0) return;

                double currNow;
                try
                {
                    int li = (_barsM5 != null ? _barsM5.Count - 1 : -1);
                    currNow = (li >= 0) ? _barsM5.ClosePrices[li] : (Symbol.Bid + Symbol.Ask) * 0.5;
                }
                catch { currNow = (Symbol.Bid + Symbol.Ask) * 0.5; }

                foreach (var po in toExpire)
                {
                    string label = po.Label ?? string.Empty;
                    string trig  = ExtractTriggerTag(label) ?? "NA";
                    bool   isBuy = (po.TradeType == TradeType.Buy);

                    // --- métricas "live" para orders.csv (si las tenemos)
                    double? bestReachPrice = null;
                    double? minDistPips    = null;
                    if (_liveById.TryGetValue(po.Id, out var live))
                    {
                        if (IsFiniteDouble(live.BestReachPrice))
                            bestReachPrice = live.BestReachPrice;

                        if (IsFiniteDouble(live.MinDistPips) && !double.IsInfinity(live.MinDistPips))
                            minDistPips = live.MinDistPips;
                    }
                    else
                    {
                        // Fallback: distancia instantánea a la entrada usando TargetPrice
                        try
                        {
                            if (po.TargetPrice > 0)
                                minDistPips = PriceToPips(Math.Abs(currNow - po.TargetPrice));
                        }
                        catch { /* no-op */ }
                    }
                    // --- agregadores / telemetría
                    string reasonCanon = Canon.NormalizeCancel("EXPIRED_TIMEOUT");
                    _runAgg?.OnOrderCanceled(trig, reasonCanon);
                    _tm?.IncOrderExpired();
                    _tm?.OnOrderCanceled(trig, isBuy, reasonCanon);
                    _orders?.OnCanceled(po.Id.ToString(), now, reasonCanon, bestReachPrice, minDistPips);
                    // --- cancelar + limpieza de trackings
                    CancelPendingOrderSafe(po);
                    _orderIdByLabel.Remove(label);
                    _liveById.Remove(po.Id);
                }
            }
            catch (Exception ex)
            {
                Print($"[ERR][CheckPendingExpirations] {ex.Message}");
            }
        }
        // =========================
        //       SL/TP / SIZING
        // =========================
        private double ComputeSLPipsFromATRAndStructure(bool up)
        {
            int i = _barsM5.Count - 1;
            // ATR seguro (si no hay, usa mínimo permitido)
            double atrPips = SafeAtrPips(i);
            if (atrPips <= 0) atrPips = SL_MinPips;
            // Componente ATR, acotado por tus min/max
            double slFromATR = Math.Max(SL_MinPips, SL_ATR_Mult * atrPips);
            // Componente estructural por swing (con fallback a barra actual)
            double structPips = ComputeStructuralSL_FromSwings(up, i, Policy.STRUCT_SL_PAD_PIPS);
            // Toma el más conservador (mayor) y recorta al techo global
            double sl = Math.Max(slFromATR, structPips);
            if (sl < SL_MinPips) sl = SL_MinPips;
            if (sl > SL_MaxPips) sl = SL_MaxPips;

            return sl;
        }

        private void PrintTriggerStats(string prefix)
        {
            foreach (var kv in _sigCount)
            {
                var tag = kv.Key; int sig = kv.Value;
                int w = _winCount[tag], l = _lossCount[tag];
                double wr = (w + l) > 0 ? (100.0 * w / (w + l)) : 0;
                double pnl = _pnlPerTag[tag];
                Print($"{prefix} TRIG={tag} | signals={sig} wins={w} losses={l} WR={wr:F1}% PnL={pnl:F2}");
            }
        }

        private (double tp1Pips, double tp2Pips) ComputeTPs(double slPips)
        {
            double tp1 = 0.0, tp2 = 0.0;
            if (TP_Mode.Equals("RMultiple", StringComparison.OrdinalIgnoreCase))
            {
                if (EnableTP1) tp1 = Math.Max(Policy.TP1_MIN_PIPS, TP1_R * slPips);
                if (EnableTP2) tp2 = Math.Max(Policy.TP2_MIN_PIPS, TP2_R * slPips);
            }
            else
            {
                if (EnableTP1) tp1 = TP1_Pips;
                if (EnableTP2) tp2 = TP2_Pips;
            }
            tp1 = Math.Min(tp1, Policy.TP_CAP_PIPS);
            tp2 = Math.Min(tp2, Policy.TP_CAP_PIPS);

            return (tp1, tp2);
        }

        private double ComputePositionSizeUnits(double slPips, double riskPct)
        {
            if (UseFixedLots)
            {
                double unitsFixed = FixedLots * Symbol.LotSize;
                return NormalizeVolume(unitsFixed);
            }

            if (slPips <= 0) return 0;

            double equity = Account.Equity;
            double riskMoney = equity * (riskPct / 100.0);

            double pipValuePerUnit = Symbol.PipValue / Symbol.LotSize;
            double riskPerUnit = slPips * pipValuePerUnit;

            if (riskPerUnit <= 0) return 0;
            double unitsDyn = riskMoney / riskPerUnit;

            return NormalizeVolume(unitsDyn);
        }

        private double NormalizeVolume(double units)
        {
            double min = Symbol.VolumeInUnitsMin;
            double max = Symbol.VolumeInUnitsMax;
            double step = Symbol.VolumeInUnitsStep;

            if (units < min) units = min;
            if (units > max) units = max;

            double steps = Math.Round((units - min) / step);
            double norm = min + steps * step;
            return Math.Max(min, Math.Min(norm, max));
        }
        // =========================
        //  GESTIÓN DE POSICIONES
        // =========================
        private void ManageOpenPositions()
        {
            bool inSession = !EnableSessionFilter || IsInAnySession(Server.Time);
            // ---- snapshot de pendientes del símbolo
            var pendings = PendingOrders
                .Where(po => po.SymbolName == SymbolName)
                .ToList();

            if (!inSession && pendings.Count > 0)
                CancelAllPendingsIfAny();
            // ---- snapshot de posiciones del símbolo
            var positions = Positions
                .Where(p => p.SymbolName == SymbolName)
                .ToList();

            foreach (var pos in positions)
            {
                ApplyBEAndTrail(pos);
                if (!inSession && ForceCloseAtSessionEnd)
                    ClosePositionWithReason(pos, TelemetryFunnel.CloseReason.SessionEnd);
            }
        }

        private void ApplyBEAndTrail(Position pos)
        {
            if (pos == null || pos.StopLoss == null) return;

            bool isBuy = (pos.TradeType == TradeType.Buy);
            double entry = pos.EntryPrice;
            double sl = pos.StopLoss.Value;
            double current = isBuy ? Symbol.Bid : Symbol.Ask;
            // --- MAE/MFE (live) ---
            if (_openLegs.TryGetValue(pos.Id, out var trk))
            {
                double pipsFromEntry = PriceToPips(isBuy ? (current - trk.Entry) : (trk.Entry - current));
                if (pipsFromEntry > trk.MfePips) trk.MfePips = pipsFromEntry;

                double adversePips = -pipsFromEntry;            // si va en contra, será positivo
                if (adversePips > trk.MaePips) trk.MaePips = adversePips;
            }

            double distSL = PriceToPips(Math.Abs(entry - sl));
            if (distSL <= 0) return;

            double movePips = PriceToPips(isBuy ? (current - entry) : (entry - current));
            double rMultiple = movePips / distSL;
            // --- BreakEven ---
            if (rMultiple >= BreakEvenAt_R)
            {
                double be = entry;
                double? newSL = isBuy
                    ? Math.Max(pos.StopLoss.Value, be)
                    : Math.Min(pos.StopLoss.Value, be);

                bool willChange = !pos.StopLoss.HasValue || newSL.Value != pos.StopLoss.Value;
                if (willChange)
                {
        #pragma warning disable 618
                    ModifyPosition(pos, newSL, pos.TakeProfit);
        #pragma warning restore 618
                    _tm?.IncBE();

                    if (_openLegs.TryGetValue(pos.Id, out var trk2) && trk2.BeTime == null)
                        trk2.BeTime = Server.Time;
                }
            }
            // --- Trailing ---
            if (rMultiple >= TrailAfter_R)
            {
                double step = PipsToPrice(TrailStepPips);
                double target = isBuy ? current - step : current + step;

                double? newSL = isBuy
                    ? Math.Max(pos.StopLoss.Value, target)
                    : Math.Min(pos.StopLoss.Value, target);

                bool willChange = !pos.StopLoss.HasValue || newSL.Value != pos.StopLoss.Value;
                if (willChange)
                {
        #pragma warning disable 618
                    ModifyPosition(pos, newSL, pos.TakeProfit);
        #pragma warning restore 618
                    _tm?.IncTrail();

                    if (_openLegs.TryGetValue(pos.Id, out var trk3))
                    {
                        trk3.NTrailSteps++;
                        if (trk3.FirstTrailTime == null) trk3.FirstTrailTime = Server.Time;
                    }
                }
            }
        }

        private void ClosePositionWithReason(Position pos, TelemetryFunnel.CloseReason reason)
        {
            try
            {
                if (pos == null) return;
                _tm.IncForceClose();
                ClosePosition(pos);
            }
            catch (Exception ex) { Print($"[ERR][ClosePositionWithReason] {ex.Message}"); }
        }
        // ===============================================
        //  ESTRUCTURAS O(1) AMORTIZADO: extremos deslizantes por ÍNDICE
        // ===============================================
        private sealed class MonoMax
        {
            private readonly LinkedList<int> dq = new LinkedList<int>();
            private readonly Func<int,double> accessor;
            private int window;

            public MonoMax(Func<int,double> accessor, int window)
            {
                this.accessor = accessor;
                this.window = Math.Max(1, window);
            }

            public void SetWindow(int w) => window = Math.Max(1, w);

            public void Push(int i)
            {
                double v = accessor(i);
                while (dq.Count > 0 && accessor(dq.Last.Value) <= v) dq.RemoveLast();
                dq.AddLast(i);

                int left = i - window + 1;
                while (dq.Count > 0 && dq.First.Value < left) dq.RemoveFirst();
            }

            public double CurrentMax(int i)
            {
                if (dq.Count == 0) return double.NaN;
                int left = i - window + 1;
                while (dq.Count > 0 && dq.First.Value < left) dq.RemoveFirst();
                return dq.Count == 0 ? double.NaN : accessor(dq.First.Value);
            }
        }
        private sealed class MonoMin
        {
            private readonly LinkedList<int> dq = new LinkedList<int>();
            private readonly Func<int,double> accessor;
            private int window;

            public MonoMin(Func<int,double> accessor, int window)
            {
                this.accessor = accessor;
                this.window = Math.Max(1, window);
            }

            public void SetWindow(int w) => window = Math.Max(1, w);

            public void Push(int i)
            {
                double v = accessor(i);
                while (dq.Count > 0 && accessor(dq.Last.Value) >= v) dq.RemoveLast();
                dq.AddLast(i);

                int left = i - window + 1;
                while (dq.Count > 0 && dq.First.Value < left) dq.RemoveFirst();
            }

            public double CurrentMin(int i)
            {
                if (dq.Count == 0) return double.NaN;
                int left = i - window + 1;
                while (dq.Count > 0 && dq.First.Value < left) dq.RemoveFirst();
                return dq.Count == 0 ? double.NaN : accessor(dq.First.Value);
            }
        }
        // Consolidación + caja: devuelve high/low, rango en pips, flag consolidated
        private (double hi, double lo, double boxRangePips, bool consolidated) 
            ConsolidationBox(int i, int lookback, double atrPips, double consRangeMult, int clampLB = 0)
        {
            int lb = (clampLB > 0) ? Math.Min(clampLB, i) : Math.Min(lookback, i);
            if (lb <= 0 || i < 0) return (double.NaN, double.NaN, 0.0, false);

            int from = Math.Max(0, i - lb + 1);
            double hi = double.MinValue, lo = double.MaxValue;

            for (int x = from; x <= i; x++)
            {
                double H = _barsM5.HighPrices[x];
                double L = _barsM5.LowPrices[x];
                if (H > hi) hi = H;
                if (L < lo) lo = L;
            }

            double boxRangePips = PriceToPips(hi - lo);
            bool consolidated = (atrPips > 0) && (boxRangePips <= consRangeMult * atrPips);

            return (hi, lo, boxRangePips, consolidated);
        }
       // =====================================================
        //  ON STOP — Limpieza + resumen + meta END
        // =====================================================
       protected override void OnStop()
        {
            // --- Limpieza de caches locales
            _boxCache.Clear();
            _metricsCache.Clear();
            _expectedEntryByLabel.Clear();
            // --- Desuscribir eventos (defensivo)
            try
            {
                Positions.Closed -= OnPositionsClosed;
                Positions.Opened -= OnPositionOpened;
            }
            catch { /* no-op */ }
            // --- Cancelar todas las pendientes del símbolo (telemetría: BotStop)
            CancelAllPendingsIfAny(TelemetryFunnel.CancelReason.BotStop);
            // --- Cerrar todas las posiciones del símbolo (telemetría: force-close)
            var positionsToClose = Positions.Where(p => p.SymbolName == SymbolName).ToList();
            foreach (var pos in positionsToClose)
                ClosePositionWithReason(pos, TelemetryFunnel.CloseReason.BotStop);
            // --- Reset de control de riesgo/cooldown
            _cooldownUntil = DateTime.MinValue;
            _consecLosses = 0;
            _riskTodayPct = 0;
            // Cierre de loggers de trades y orders (runtime CSVs)
            try { _trades?.Close(); } catch { /* no-op */ }
            try { _orders?.Dispose(); } catch { /* no-op */ }
            // ====== RESUMEN FINAL (estadísticas locales) ======
            double seen   = Math.Max(1, _barsSeen);
            double nOK    = _barsPassedNoise;
            double rOK    = _barsPassedRegime;

            double pNoise = 100.0 * (nOK / seen);
            double pReg   = 100.0 * (rOK / seen);
            double pRegOnNoise = (nOK > 0) ? 100.0 * (rOK / nOK) : 0.0;

            Print("──────────────── Embudo final");
            Print($"Vistas={_barsSeen} | NoiseOK={_barsPassedNoise} ({pNoise:F1}%) | RegimeOK={_barsPassedRegime} ({pReg:F1}% del total, {pRegOnNoise:F1}% de NoiseOK)");
            Print($"Rechazos → Spread={_rejSpread}, ATR={_rejATR}, Trend={_rejTrend}, Proximity={_rejProximity}");
            Print($"Signals: BOS={_sigCount["BOS"]}, ENG={_sigCount["ENG"]}, PIN={_sigCount["PIN"]}, FBK={_sigCount["FBK"]}, MOM={_sigCount["MOM"]}");
            PrintTriggerStats("Final");
            Print($"HighWater: metricsCache={_maxMetricsCache}, boxCache={_maxBoxCache}, expectedLabels={_maxExpectedLabels}");
            // ====== Embudo total (día acumulado → total) ======
            try { _tm?.FlushFinal(); } catch { }
            // Marca de parada + metadatos fin
            Print("TEMA Scalper detenido. Hora server: {0}", Server.Time);
            // Cierre de signals.csv
            try
            {
                if (_signalsWriter != null)
                {
                    _signalsWriter.Flush();
                    _signalsWriter.Dispose();
                    _signalsWriter = null;
                }
            }
            catch (Exception ex) { Print($"[ERR][signals.csv close] {ex.Message}"); }
            // ====== Punto 9) Flush final del daily y cierre ======
            try { if (_daily != null) _dailyLogger?.Append(_daily, _runId, _currentDate, this); }
            catch (Exception ex) { Print($"[ERR][daily.csv final append] {ex.Message}"); }

            try { _dailyLogger?.Close(); } catch { /* no-op */ }
            try { _runAgg?.PrintFinalReport(); } catch (Exception ex) { Print($"[ERR][RunAgg] {ex.Message}"); }
            // Meta fin
            LogMeta("END");
        }
        // =========================
        //     UTILS & NIVELES
        // =========================
        private void RefreshBarMetrics(int i)
        {
            if (_metricsCache.TryGetValue(i, out var cached) && cached.IsValid)
            {
                if (_metricsCache.Count > 500)
                {
                    var keysToRemove = _metricsCache.Keys.Where(k => k < i - 100).ToList();
                    foreach (var key in keysToRemove)
                        _metricsCache.Remove(key);
                }
                _mO = cached.O; _mC = cached.C; _mH = cached.H; _mL = cached.L;
                _mAtrPips = cached.AtrPips; _mRangePips = cached.RangePips;
                _mBodyPct = cached.BodyPct; _mEma20SlopePips = cached.Ema20SlopePips;
                _mEntryBufPips = cached.EntryBufPips;
                _metricsBarIndex = i;
                return;
            }

            _mO = _barsM5.OpenPrices[i];
            _mC = _barsM5.ClosePrices[i];
            _mH = _barsM5.HighPrices[i];
            _mL = _barsM5.LowPrices[i];

            double range = _mH - _mL;
            _mRangePips = PriceToPips(range);
            double body = Math.Abs(_mC - _mO);
            _mBodyPct = (range > 0) ? (100.0 * (body / range)) : 0.0;

            _mAtrPips = SafeAtrPips(i);
            if (_mAtrPips <= 0) _mAtrPips = 1.0; // fallback mínimo

            _mEma20SlopePips = (i > 0) ?
                PriceToPips(Math.Abs(_emaMed.Result[i] - _emaMed.Result[i - 1])) : 0.0;

            _mEntryBufPips = ComputeEntryBufferFromContext(i, _mAtrPips);

            _metricsCache[i] = new BarMetrics
            {
                O = _mO, C = _mC, H = _mH, L = _mL,
                AtrPips = _mAtrPips, RangePips = _mRangePips,
                BodyPct = _mBodyPct, Ema20SlopePips = _mEma20SlopePips,
                EntryBufPips = _mEntryBufPips, IsValid = true
            };

            _metricsBarIndex = i;
        }

        private double ComputeEntryBufferFromAtr(double atrPips)
        {
            double buf = EntryBufferPips;
            if (EntryBufferAtrMult > 0 && atrPips > 0 && IsFiniteDouble(atrPips))
                buf = Math.Max(buf, EntryBufferAtrMult * atrPips);
            if (buf < EntryBufferMinPips) buf = EntryBufferMinPips;
            if (buf > EntryBufferMaxPips) buf = EntryBufferMaxPips;
            return buf;
        }
        // Cabecera CSV (solo una vez)
        private void WriteSignalsHeaderIfNeeded()
        {
            if (_signalsWriter == null || _signalsHeaderWritten) return;
            _signalsWriter.WriteLine(string.Join(",",
                "run_id","signal_id","time_iso","bar_index","symbol","timeframe",
                "tag","dir","action","skip_reason",
                "noise_ok","regime_ok","zone_ok","reentry_blocked","trigger_cooling",
                "atr_pips","spread_pips","ema20_slope_pips","body_pct","range_pips",
                "micro_box_range_pips","macro_box_hi","macro_box_lo",
                "price_vs_ema20_pips","dist_to_level_pips",
                "dyn_min_beyond_pips","entry_buffer_pips"
            ));
            _signalsHeaderWritten = true;
        }
        // distancia (en pips) al nivel activo más cercano (PDH/PDL/AsiaH/AsiaL/Round)
        private double DistToNearestLevelPips(double price)
        {
            var candidates = new List<double>();

            if (EnablePrevDayLevels && _PDH.HasValue) candidates.Add(Math.Abs(price - _PDH.Value));
            if (EnablePrevDayLevels && _PDL.HasValue) candidates.Add(Math.Abs(price - _PDL.Value));
            if (EnableAsiaLevels && _AsiaH.HasValue)  candidates.Add(Math.Abs(price - _AsiaH.Value));
            if (EnableAsiaLevels && _AsiaL.HasValue)  candidates.Add(Math.Abs(price - _AsiaL.Value));

            if (EnableRoundNumbers && RoundStepPips > 0)
            {
                double stepPrice = PipsToPrice(RoundStepPips);
                double nearest   = Math.Round(price / stepPrice) * stepPrice;
                candidates.Add(Math.Abs(price - nearest));
            }

            if (candidates.Count == 0) return double.NaN;
            return PriceToPips(candidates.Min());
        }
        // genera un id estable y legible por señal (run + bar + secuencia + trig + lado)
        private string NewSignalId(string tag, bool up, int barIndex)
        {
            var t = (barIndex >= 0 && barIndex < Bars.Count) ? Bars.OpenTimes[barIndex] : Server.Time;
            var side = up ? "L" : "S";
            long seq = System.Threading.Interlocked.Increment(ref _signalSeq);
            return $"{_runId}:{t:yyyyMMdd-HHmmss}:{barIndex}:{tag}:{side}:{seq}";
        }
        private string MakeMarketOrderId(string label) => $"MKT:{_runId}:{label}";
        // escritura robusta: si no hay permisos, lo imprime
        private void WriteSignalRow(params object[] cols)
        {
            string line = string.Join(",", cols.Select(v =>
            {
                if (v == null) return "";
                string s = Convert.ToString(v, CultureInfo.InvariantCulture);
                // CSV-safe (sin comillas para valores simples)
                s = s.Replace("\"", "\"\"");
                return s.Contains(",") ? $"\"{s}\"" : s;
            }));

            if (_signalsWriter != null)
            {
                _signalsWriter.WriteLine(line);
                // flush ligero para no perder datos en backtests largos (puedes comentar si prefieres rendimiento)
                _signalsWriter.Flush();
            }
            else
            {
                Print($"[signals.csv] {line}");
            }
        }
        // logger unificado de señales (una fila por señal, se opere o no)
        private void LogSignalCsv(
            string tag, bool up, int barIndex,
            bool zoneOk, bool reentryBlocked, bool triggerCooling,
            string action, RejectCode skipReason,
            double dynMinBeyondPips, double? spreadAtSignalPips = null)
        {
            // contexto bar y métricas
            RefreshBarMetrics(barIndex);
            double timeSpreadPips = PointsToPips(Symbol.Spread);
            double ema20 = _emaMed.Result[barIndex];
            double price = _mC;

            var (miH, miL) = GetMicroBoxHL_Fast(barIndex);
            var (maH, maL) = GetReentryBoxHL_Fast(barIndex);
            double microRangePips = PriceToPips(miH - miL);

            double distLevelP = DistToNearestLevelPips(price);
            double priceVsEma = PriceToPips(price - ema20);

            string id = NewSignalId(tag, up, barIndex);

            WriteSignalsHeaderIfNeeded();
            WriteSignalRow(
                _runId, id, Bars.OpenTimes[barIndex].ToString("o"), barIndex, SymbolName, Bars.TimeFrame.ToString(),
                tag, (up ? "long" : "short"), action, skipReason.ToString(),
                _lastNoiseOk ? 1 : 0, _lastRegimeOk ? 1 : 0, zoneOk ? 1 : 0, reentryBlocked ? 1 : 0, triggerCooling ? 1 : 0,
                _mAtrPips, timeSpreadPips, _mEma20SlopePips, _mBodyPct, _mRangePips,
                microRangePips, maH, maL,
                priceVsEma, distLevelP,
                dynMinBeyondPips, _mEntryBufPips
            );
        }


        private double ComputeEntryBufferFromContext(int i, double atrPips)
        {
            // Base: modo ATR + clamps
            double buf = EntryBufferPips;

            if (EntryBufferAtrMult > 0 && atrPips > 0 && IsFiniteDouble(atrPips))
                buf = Math.Max(buf, EntryBufferAtrMult * atrPips);

            buf = Math.Max(EntryBufferMinPips, Math.Min(buf, EntryBufferMaxPips));

            // Ajuste por “micro-box ancha” (rangos erráticos)
            var (bhMi, blMi) = GetMicroBoxHL_Fast(i);
            if (!double.IsNaN(bhMi) && !double.IsNaN(blMi) && atrPips > 0 && IsFiniteDouble(atrPips))
            {
                double boxRangeMiPips = PriceToPips(bhMi - blMi);
                double wideThreshold  = Policy.MICROBOX_WIDE_FRAC_OF_LIMIT * MicroBoxMaxRangeAtrMult * atrPips;

                if (boxRangeMiPips >= wideThreshold)
                {
                    buf += Math.Max(0.0, EntryBufExtraIfBoxWide);
                }
            }

            // Clamp final por seguridad
            buf = Math.Max(EntryBufferMinPips, Math.Min(buf, EntryBufferMaxPips));
            return buf;
        }

        private bool HasOpenSameSide(bool up)
        {
            if (Positions == null || Positions.Count == 0) return false;

            var tt = up ? TradeType.Buy : TradeType.Sell;

            for (int i = 0; i < Positions.Count; i++)
            {
                var pos = Positions[i];
                if (pos.SymbolName == SymbolName && pos.TradeType == tt)
                    return true;
            }

            return false;
        }

        private bool IsNearAnyActiveLevel(double price, double proxPips)
        {
            double proxPrice = PipsToPrice(proxPips);
            // Prev Day H/L
            if (EnablePrevDayLevels)
            {
                if (_PDH.HasValue && Math.Abs(price - _PDH.Value) <= proxPrice) return true;
                if (_PDL.HasValue && Math.Abs(price - _PDL.Value) <= proxPrice) return true;
            }
            // Asia H/L del día
            if (EnableAsiaLevels)
            {
                if (_AsiaH.HasValue && Math.Abs(price - _AsiaH.Value) <= proxPrice) return true;
                if (_AsiaL.HasValue && Math.Abs(price - _AsiaL.Value) <= proxPrice) return true;
            }

            // Round numbers (grid por pasos de RoundStepPips)
            if (EnableRoundNumbers && RoundStepPips > 0.0)
            {
                double stepPrice = PipsToPrice(RoundStepPips);
                if (stepPrice > 0.0)
                {
                    double nearest = Math.Round(price / stepPrice) * stepPrice;
                    if (Math.Abs(price - nearest) <= proxPrice) return true;
                }
            }

            return false;
        }

        private void OnPositionOpened(PositionOpenedEventArgs e)
        {
            try
            {
                var pos = e.Position;
                bool cameFromPending = false;   // ← nuevo
                long pendingId = 0;             // ← nuevo
                DateTime placedTime = Server.Time; // ya lo usas, mantenlo aquí
                double ttfSec = -1;             // ya lo usas, mantenlo aquí

                if (pos == null || pos.SymbolName != SymbolName) return;

                long   pid   = pos.Id;
                string label = pos.Label ?? string.Empty;
                bool   isBuy = pos.TradeType == TradeType.Buy;
                string trig  = ExtractTriggerTag(label) ?? "NA";
                // --- slippage
                bool   hadExpected   = _expectedEntryByLabel.TryGetValue(label, out var expected);
                double entry         = pos.EntryPrice;
                double expectedEntry = hadExpected ? expected : entry;
                double slipPips      = hadExpected
                                        ? PriceToPips(isBuy ? (entry - expectedEntry) : (expectedEntry - entry))
                                        : 0.0;
                // ===== Daily fill stats (spread, slippage, risk) =====
                _daily?.OnTradeOpen(Server.Time, RiskPerTradePct, slipPips, PointsToPips(Symbol.Spread));
              
                if (_orderIdByLabel.TryGetValue(label, out var ordId) && ordId > 0)
                {
                    // STOP (venía de una pending real)
                    cameFromPending = true;
                    pendingId = ordId;

                    if (_liveById.TryGetValue(ordId, out var ol))
                    {
                        placedTime = ol.TimePlaced;
                        ttfSec     = Math.Max(0.0, (Server.Time - ol.TimePlaced).TotalSeconds);
                    }

                    try { _orders?.OnFilled(ordId.ToString(), Server.Time); } catch { /* no-op */ }
                    _liveById.Remove(ordId);
                    _orderIdByLabel.Remove(label);        // limpia el mapeo STOP
                }
                else if (_marketOrderIdByLabel.TryGetValue(label, out var mktId))
                {
                    // MARKET (ID sintético)
                    try { _orders?.OnFilled(mktId, Server.Time); } catch { /* no-op */ }
                    _marketOrderIdByLabel.Remove(label);  // limpia el mapeo MARKET
                    _orderIdByLabel.Remove(label);        // elimina el marcador 0 si lo pusiste
                }
                else
                {
                    // Fallback ultra defensivo: si por alguna razón no estaba mapeado,
                    // intenta cerrar con el ID sintético determinista derivado del label.
                    try { _orders?.OnFilled(MakeMarketOrderId(label), Server.Time); } catch { /* no-op */ }
                    _orderIdByLabel.Remove(label);
                    _marketOrderIdByLabel.Remove(label);
                }
                // (en MARKET no tendremos liveId; si más adelante guardas placed-time por label, úsalo aquí)
                int i = Bars.Count - 1;
                if (i >= 0) RefreshBarMetrics(i);
                var sidFromLabel = ExtractSid(label);
                string parentSid = !string.IsNullOrEmpty(sidFromLabel) ? sidFromLabel : ParentSignalIdFallback();

                var tr = new TradeLegTrack
                {
                    PosId = pid,
                    TradeId = $"{_runId}:{pid}",
                    ParentSignalId = parentSid,
                    FromOrderRef = cameFromPending ? $"stop_from_label:{label}" : "market_direct",
                    Label = label,
                    Trig  = trig,
                    OpenTime = Server.Time,
                    OpenBarIndex = i,
                    Entry = entry,
                    ExpectedEntry = expectedEntry,
                    SlippagePips = slipPips,
                    SizeUnits = pos.VolumeInUnits,
                    RiskPctUsed = RiskPerTradePct,
                    SlPipsAtEntry = pos.StopLoss.HasValue ? PriceToPips(Math.Abs(entry - pos.StopLoss.Value)) : 0.0,
                    TpPipsAtEntry = pos.TakeProfit.HasValue ? PriceToPips(Math.Abs(pos.TakeProfit.Value - entry)) : 0.0,
                    AtrAtFill = (i >= 0) ? SafeAtrPips(i) : 0.0,
                    SpreadAtFillPips = PointsToPips(Symbol.Spread),
                    Ema20SlopeAtFillPips = _mEma20SlopePips,
                    SessionId = CurrentSessionId(Server.Time),
                    DoW = (int)Server.Time.DayOfWeek,
                    HourBin = Server.Time.Hour
                };

                _openLegs[pid] = tr;

                bool nearLevelAtFill = IsNearAnyActiveLevel(entry, LevelProximityPips);

                _runAgg?.OnFill(
                    pos.Id, trig, placedTime,
                    tr.AtrAtFill, tr.Ema20SlopeAtFillPips,
                    tr.SessionId, tr.DoW, tr.HourBin,
                    nearLevelAtFill, ttfSec
                );
                // Telemetría de fill
                try
                {
                    _tm?.OnFill(trig, isBuy, cameFromPending ? "Stop" : "Market", pos.VolumeInUnits, pos.EntryPrice, pos.StopLoss, pos.TakeProfit, slipPips);
                }
                catch { /* no-op */ }
                // Política de slippage (aplícalo tanto si era STOP como MARKET, ya que ahora tenemos expected en ambos)
                if (hadExpected)
                {
                    _expectedEntryByLabel.Remove(label);
                    if (EvaluateSlippageAndMaybeClose(pos, label, expectedEntry, isStopOrder: cameFromPending))
                        return;
                }

                CleanupOldExpectedEntries();
            }
            catch (Exception ex)
            {
                Print($"[ERR][OnPositionOpened] {ex.Message}");
            }
        }

        private void CleanupOldExpectedEntries()
        {
            try
            {
                if (_expectedEntryByLabel.Count <= 50) return;

                var alive = new HashSet<string>(
                    PendingOrders.Where(po => po.SymbolName == SymbolName)
                                 .Select(po => po.Label ?? string.Empty)
                );

                var dead = _expectedEntryByLabel.Keys.Where(k => !alive.Contains(k)).ToList();
                foreach (var k in dead) _expectedEntryByLabel.Remove(k);
            }
            catch (Exception ex)
            {
                Print($"[ERR][CleanupOldExpectedEntries] {ex.Message}");
            }
        }
        // =====================================================
        //  9) CIERRES 
        // =====================================================
        private void OnPositionsClosed(PositionClosedEventArgs args)
        {
            try
            {
                var pos = args.Position;
                if (pos == null || pos.SymbolName != SymbolName) return;
                // BE en la gemela TP2 si cerró TP1
                MoveSiblingTP2ToBEIfAny(pos.Label ?? string.Empty);

                string label = pos.Label ?? string.Empty;
                string trig  = ExtractTriggerTag(label) ?? "NA";
                bool   isBuy = pos.TradeType == TradeType.Buy;
                // Clasificación simple (luego la normalizamos con ExitReason si quieres)
                string core   = RemoveTrigPart(label);
                var exit      = Canon.ClassifyExit(pos, core);
                string reason = exit.ToString();  // pasa esto a _tm y a trades.csv
                // PnL en pips desde el gross profit (aprox)
                double unitsForPips = Math.Max(1.0, pos.VolumeInUnits);
                double pipValUnit   = Symbol.PipValue / Symbol.LotSize;
                double pnl_pips     = pos.GrossProfit / (pipValUnit * unitsForPips);
                // Cierre estimado (para CSV/log)
                double closeEst = isBuy
                    ? pos.EntryPrice + PipsToPrice(pnl_pips)
                    : pos.EntryPrice - PipsToPrice(pnl_pips);

                TimeSpan hold = Server.Time - pos.EntryTime;

                try
                {
                    if (_openLegs.TryGetValue(pos.Id, out var tr))
                    {
                        double pnl_r = (tr.SlPipsAtEntry > 0.0) ? (pnl_pips / tr.SlPipsAtEntry) : 0.0;
                        int durationBars = Math.Max(0, (Bars != null ? Bars.Count - 1 : tr.OpenBarIndex) - tr.OpenBarIndex);
                        // ► Punto 7: agregar a RunAgg (por trigger/regímenes)
                        _runAgg?.OnClose(pos.Id, pnl_r, tr.MaePips, tr.MfePips, pos.GrossProfit > 0);
                        // ► trades.csv
                        _trades?.Append(
                            trade_id: tr.TradeId,
                            parent_signal_id: tr.ParentSignalId,
                            from_order_ref: tr.FromOrderRef,
                            label: tr.Label,
                            trig: tr.Trig,
                            time_filled: tr.OpenTime,
                            entry_price: tr.Entry,
                            expected_entry: tr.ExpectedEntry,
                            slippage_pips: tr.SlippagePips,
                            size_units: tr.SizeUnits,
                            risk_pct_used: tr.RiskPctUsed,
                            sl_pips_at_entry: tr.SlPipsAtEntry,
                            tp_pips_at_entry: tr.TpPipsAtEntry,
                            be_time: tr.BeTime,
                            first_trail_time: tr.FirstTrailTime,
                            n_trail_steps: tr.NTrailSteps,
                            exit_time: Server.Time,
                            exit_price: closeEst,
                            exit_reason: reason,
                            pnl_pips: pnl_pips,
                            pnl_r: pnl_r,
                            duration_bars: durationBars,
                            mae_pips: tr.MaePips,
                            mfe_pips: tr.MfePips,
                            atr_at_fill: tr.AtrAtFill,
                            spread_at_fill_pips: tr.SpreadAtFillPips,
                            ema20_slope_at_fill_pips: tr.Ema20SlopeAtFillPips,
                            session_id: tr.SessionId,
                            dow: tr.DoW,
                            hour_bin: tr.HourBin
                        );

                        _openLegs.Remove(pos.Id);
                        // ► daily.csv (firma actual: pnl, R, isWin)
                        _daily?.OnClose(pnl_pips, pnl_r, pos.GrossProfit > 0);
                    }
                }
                catch (Exception ex)
                {
                    Print($"[ERR][trades write] {ex.Message}");
                }
                // Telemetría de cierre (embudo)
                try
                {
                    _tm?.OnClose(trig, isBuy, reason, pos.VolumeInUnits, pos.EntryPrice, closeEst,
                                 pos.GrossProfit, pos.NetProfit, pnl_pips, hold);
                }
                catch { /* no-op */ }
                // Riesgo diario / rachas + cooldown
                if (pos.GrossProfit < 0) _consecLosses++; else _consecLosses = 0;
                _riskTodayPct += RiskPerTradePct;

                if (_consecLosses >= MaxConsecLosses || _riskTodayPct >= MaxDailyRiskPct)
                {
                    var until = Server.Time.AddMinutes(CooldownMinutes);
                    RequestCooldownUntil(until);
                    RequestCancelAllPendings();
                    _daily?.OnCooldown("Risk/Cooldown");
                    Print("Cooldown solicitado hasta {0}.", until);
                }
                // Contadores por trigger (para tu snapshot rápido)
                if (!string.IsNullOrEmpty(trig))
                {
                    if (pos.GrossProfit > 0) _winCount[trig]++; else _lossCount[trig]++;
                    _pnlPerTag[trig] += pos.NetProfit;
                }
                // Bloqueo de reentrada tras pérdida
                if (pos.GrossProfit < 0)
                {
                    bool wasLong = pos.TradeType == TradeType.Buy;
                    RequestReentryBlock(wasLong);
                }
            }
            catch (Exception ex)
            {
                Print($"[ERR][OnPositionsClosed] {ex.Message}");
            }
        }
        // Pips de banda dinámica alrededor de EMA20: min(3p, 0.40×ATR)
        private double DynEmaBandPips(int i)
        {
            double atrPips = SafeAtrPips(i);
            if (atrPips <= 0) return Policy.NEAR_EMA_BAND_MAX_PIPS;
            return Math.Min(Policy.NEAR_EMA_BAND_MAX_PIPS, Policy.NEAR_EMA_BAND_ATR_MULT * atrPips);
        }
        // Devuelve true si 'low[x]' es mínimo local en [x-K, x+K]
        private bool IsLocalMin(int x, int k)
        {
            int left = Math.Max(0, x - k);
            int right = Math.Min(_barsM5.Count - 1, x + k);
            double v = _barsM5.LowPrices[x];
            for (int j = left; j <= right; j++)
                if (_barsM5.LowPrices[j] < v) return false;
            return true;
        }
        // Devuelve true si 'high[x]' es máximo local en [x-K, x+K]
        private bool IsLocalMax(int x, int k)
        {
            int left = Math.Max(0, x - k);
            int right = Math.Min(_barsM5.Count - 1, x + k);
            double v = _barsM5.HighPrices[x];
            for (int j = left; j <= right; j++)
                if (_barsM5.HighPrices[j] > v) return false;
            return true;
        }
        // Busca el swing low más RECIENTE dentro del lookback que esté dentro de la banda EMA20
        private int FindSwingLowIndex(int i, int lookback, int confirmK, double emaBandPips)
        {
            int from = Math.Max(0, i - lookback);
            for (int x = i; x >= from; x--)
            {
                if (!IsLocalMin(x, confirmK)) continue;

                double ema20 = _emaMed.Result[x];
                double low   = _barsM5.LowPrices[x];
                double distP = PriceToPips(Math.Abs(ema20 - low));
                if (distP <= emaBandPips) return x;      // elegimos el más reciente válido
            }
            return -1;
        }
        // Busca el swing high más RECIENTE dentro del lookback que esté dentro de la banda EMA20
        private int FindSwingHighIndex(int i, int lookback, int confirmK, double emaBandPips)
        {
            int from = Math.Max(0, i - lookback);
            for (int x = i; x >= from; x--)
            {
                if (!IsLocalMax(x, confirmK)) continue;

                double ema20 = _emaMed.Result[x];
                double high  = _barsM5.HighPrices[x];
                double distP = PriceToPips(Math.Abs(ema20 - high));
                if (distP <= emaBandPips) return x;      // más reciente válido
            }
            return -1;
        }
        // Calcula SL estructural en pips usando el swing más reciente + pads
        private double ComputeStructuralSL_FromSwings(bool up, int i, double basePadPips)
        {
            double emaBandPips = DynEmaBandPips(i);
            int lookback = Policy.SL_SWING_LOOKBACK_BARS;
            int k        = Policy.SL_SWING_CONFIRM_K;

            double priceClose = _barsM5.ClosePrices[i];

            if (up)
            {
                int idx = FindSwingLowIndex(i, lookback, k, emaBandPips);
                if (idx >= 0)
                {
                    double swingLow = _barsM5.LowPrices[idx];
                    double dist = PriceToPips(priceClose - swingLow);
                    double pad  = basePadPips + Policy.SL_STRUCT_EXTRA_PAD_PIPS;
                    return Math.Max(0.0, dist + pad);
                }
                // fallback si no hay swing válido
                double structNow = PriceToPips(priceClose - _barsM5.LowPrices[i]) + basePadPips;
                return Math.Max(0.0, structNow);
            }
            else
            {
                int idx = FindSwingHighIndex(i, lookback, k, emaBandPips);
                if (idx >= 0)
                {
                    double swingHigh = _barsM5.HighPrices[idx];
                    double dist = PriceToPips(swingHigh - priceClose);
                    double pad  = basePadPips + Policy.SL_STRUCT_EXTRA_PAD_PIPS;
                    return Math.Max(0.0, dist + pad);
                }
                // fallback si no hay swing válido
                double structNow = PriceToPips(_barsM5.HighPrices[i] - priceClose) + basePadPips;
                return Math.Max(0.0, structNow);
            }
        }
    }
    // --- Helpers de normalización y mapeo de razones de cancelación ---
    public static class Canon
    {
        // Devuelve siempre una razón canónica en MAYÚSCULAS con underscores
        public static string NormalizeCancel(string raw)
        {
            if (string.IsNullOrWhiteSpace(raw)) return "MANUAL";

            string s = raw.Trim().ToUpperInvariant()
                          .Replace(" ", "_")
                          .Replace("-", "_");

            // Normalizaciones conocidas (alias → forma canónica)
            if (s == "TRENDMISALIGNED") s = "TREND_MISALIGNED";
            if (s == "FBKOPPOSITEDRIFT") s = "FBK_OPPOSITE_DRIFT";
            if (s == "MICROBOXTOOWIDE") s = "MICRO_BOX_TOO_WIDE";
            if (s == "TWOOPPCLOSESBEYOND") s = "TWO_OPP_CLOSES_BEYOND";
            if (s == "REGIMECHANGE") s = "REGIME_CHANGE";
            if (s == "SLIPPAGEADVERSE") s = "SLIPPAGE_ADVERSE";
            if (s == "BOTSTOP") s = "BOT_STOP";
                       return s;
        }
        // --- Clasificación simple de cierres (por etiqueta) ---
        public enum ExitReason
        {
            TakeProfit,
            StopLoss,
            TrailingStop,
            Timeout,
            Manual
        }
        
        public static ExitReason ClassifyExit(object pos, string core)
        {
            string s = (core ?? string.Empty).Trim().ToUpperInvariant();

            if (s.Contains("TP"))            return ExitReason.TakeProfit;
            if (s.Contains("SL"))            return ExitReason.StopLoss;
            if (s.Contains("TS") ||
                s.Contains("TRAIL"))         return ExitReason.TrailingStop;
            if (s.Contains("TIMEOUT") ||
                s.Contains("EXP"))           return ExitReason.Timeout;

            return ExitReason.Manual;
        }
       
    }
}
   